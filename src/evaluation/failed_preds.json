[
    {
        "mut_no": 1008,
        "test_method": "org.jfree.chart.renderer.xy.junit.XYAreaRendererTests.testDrawWithNullInfo",
        "source_method": "createBufferedImage(int,int,int,org.jfree.chart.ChartRenderingInfo)",
        "src_lines": [
            "public BufferedImage createBufferedImage(int width, int height,",
            "int imageType,",
            "ChartRenderingInfo info) {",
            "BufferedImage image = new BufferedImage(width, height, imageType);",
            "if (info != null) {",
            "info.setRenderingSource(new BufferedImageRenderingSource(image));",
            "}",
            "Graphics2D g2 = image.createGraphics();",
            "draw(g2, new Rectangle2D.Double(0, 0, width, height), null, info);",
            "g2.dispose();",
            "return image;",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testDrawWithNullInfo() {",
            "boolean success = false;",
            "try {",
            "DefaultTableXYDataset dataset = new DefaultTableXYDataset();",
            "",
            "XYSeries s1 = new XYSeries(\"Series 1\", true, false);",
            "s1.add(5.0, 5.0);",
            "s1.add(10.0, 15.5);",
            "s1.add(15.0, 9.5);",
            "s1.add(20.0, 7.5);",
            "dataset.addSeries(s1);",
            "",
            "XYSeries s2 = new XYSeries(\"Series 2\", true, false);",
            "s2.add(5.0, 5.0);",
            "s2.add(10.0, 15.5);",
            "s2.add(15.0, 9.5);",
            "s2.add(20.0, 3.5);",
            "dataset.addSeries(s2);",
            "XYPlot plot = new XYPlot(dataset,",
            "new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
            "new XYAreaRenderer());",
            "JFreeChart chart = new JFreeChart(plot);",
            "/* BufferedImage image = */ chart.createBufferedImage(300, 200,",
            "null);",
            "success = true;",
            "}",
            "catch (NullPointerException e) {",
            "e.printStackTrace();",
            "success = false;",
            "}",
            "assertTrue(success);",
            "}"
        ],
        "before_pmt": "info, !=, null,",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 4,
        "label": 1
    },
    {
        "mut_no": 3765,
        "test_method": "com.google.gson.functional.StreamingTypeAdaptersTest.testDeserializeNullField",
        "source_method": "create(com.google.gson.Gson,com.google.gson.reflect.TypeToken<T>)",
        "src_lines": [
            "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {",
            "Type type = typeToken.getType();",
            "",
            "Class<? super T> rawType = typeToken.getRawType();",
            "if (!Collection.class.isAssignableFrom(rawType)) {",
            "return null;",
            "}",
            "",
            "Type elementType = $Gson$Types.getCollectionElementType(type, rawType);",
            "TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));",
            "ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);",
            "",
            "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter",
            "TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);",
            "return result;",
            "}"
        ],
        "new_line": "if (!true) {",
        "tst_lines": [
            "public void testDeserializeNullField() throws IOException {",
            "Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':null}\".replace('\\'', '\\\"'));",
            "assertNull(truck.passengers);",
            "}"
        ],
        "before_pmt": "Collection, ., class, ., isAssignableFrom, (, rawType, ),",
        "after_pmt": "true,",
        "mutator": "COR",
        "mut_src_line_no": 4,
        "label": 1
    },
    {
        "mut_no": 2869,
        "test_method": "com.google.gson.functional.CustomTypeAdaptersTest.testEnsureCustomDeserializerNotInvokedForNullValues",
        "source_method": "create(com.google.gson.Gson,com.google.gson.reflect.TypeToken<T>)",
        "src_lines": [
            "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {",
            "Class<? super T> rawType = targetType.getRawType();",
            "JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);",
            "if (annotation == null) {",
            "return null;",
            "}",
            "return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testEnsureCustomDeserializerNotInvokedForNullValues() {",
            "Gson gson = new GsonBuilder()",
            ".registerTypeAdapter(DataHolder.class, new DataHolderDeserializer())",
            ".create();",
            "String json = \"{wrappedData:null}\";",
            "DataHolderWrapper actual = gson.fromJson(json, DataHolderWrapper.class);",
            "assertNull(actual.wrappedData);",
            "}"
        ],
        "before_pmt": "annotation, ==, null,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 1
    },
    {
        "mut_no": 28,
        "test_method": "org.apache.commons.csv.CSVPrinterTest.testEscapeBackslash2",
        "source_method": "isLineBreak(java.lang.Character)",
        "src_lines": [
            "private static boolean isLineBreak(final Character c) {",
            "return c != null && isLineBreak(c.charValue());",
            "}"
        ],
        "new_line": "return c != null;",
        "tst_lines": [
            "public void testEscapeBackslash2() throws IOException {",
            "final StringWriter sw = new StringWriter();",
            "try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) {",
            "printer.print(\"\\\\\\r\");",
            "}",
            "assertEquals(\"'\\\\\\r'\", sw.toString());",
            "}"
        ],
        "before_pmt": "c, !=, null, &&, isLineBreak, (, c, ., charValue, (, ), ),",
        "after_pmt": "c, !=, null,",
        "mutator": "COR",
        "mut_src_line_no": 1,
        "label": 1
    },
    {
        "mut_no": 25,
        "test_method": "org.apache.commons.csv.CSVParserTest.testExcelFormat1",
        "source_method": "isLineBreak(java.lang.Character)",
        "src_lines": [
            "private static boolean isLineBreak(final Character c) {",
            "return c != null && isLineBreak(c.charValue());",
            "}"
        ],
        "new_line": "return true && isLineBreak(c.charValue());",
        "tst_lines": [
            "public void testExcelFormat1() throws IOException {",
            "final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\" +",
            "\"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";",
            "final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" },",
            "{ \"  x\", \"\", \"\", \"\" }, { \"\" }, { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };",
            "try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {",
            "final List<CSVRecord> records = parser.getRecords();",
            "assertEquals(res.length, records.size());",
            "assertTrue(records.size() > 0);",
            "for (int i = 0; i < res.length; i++) {",
            "assertArrayEquals(res[i], records.get(i).values());",
            "}",
            "}",
            "}"
        ],
        "before_pmt": "c, !=, null,",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 1,
        "label": 1
    },
    {
        "mut_no": 77287,
        "test_method": "org.jfree.data.time.junit.QuarterTests.testGetLastMillisecond",
        "source_method": "peg(java.util.Calendar)",
        "src_lines": [
            "public void peg(Calendar calendar) {",
            "this.firstMillisecond = getFirstMillisecond(calendar);",
            "this.lastMillisecond = getLastMillisecond(calendar);",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testGetLastMillisecond() {",
            "Locale saved = Locale.getDefault();",
            "Locale.setDefault(Locale.UK);",
            "TimeZone savedZone = TimeZone.getDefault();",
            "TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));",
            "Quarter q = new Quarter(3, 1970);",
            "assertEquals(23583599999L, q.getLastMillisecond());",
            "Locale.setDefault(saved);",
            "TimeZone.setDefault(savedZone);",
            "}"
        ],
        "before_pmt": "this, ., lastMillisecond, =, getLastMillisecond, (, calendar, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 2,
        "label": 1
    },
    {
        "mut_no": 32057,
        "test_method": "org.jfree.chart.axis.junit.LogarithmicAxisTests.testJava2DToValue",
        "source_method": "adjustedPow10(double)",
        "src_lines": [
            "public double adjustedPow10(double val) {",
            "boolean negFlag = (val < 0.0);",
            "if (negFlag) {",
            "val = -val; // if negative then set flag and make positive",
            "}",
            "double res;",
            "if (val < 1.0) {",
            "res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10",
            "}",
            "else {",
            "res = Math.pow(10, val);",
            "}",
            "return negFlag ? (-res) : res;",
            "}"
        ],
        "new_line": "if (val != 1.0) {",
        "tst_lines": [
            "public void testJava2DToValue() {",
            "Rectangle2D plotArea = new Rectangle2D.Double(22, 33, 500, 500);",
            "RectangleEdge edge = RectangleEdge.BOTTOM;",
            "",
            "// set axis bounds to be both greater than 1",
            "this.axis.setRange(10, 20);",
            "checkPointsToValue(edge, plotArea);",
            "",
            "// check for bounds interval that includes 1",
            "this.axis.setRange(0.5, 10);",
            "checkPointsToValue(edge, plotArea);",
            "",
            "// check for bounds interval that includes 1",
            "this.axis.setRange(0.2, 20);",
            "checkPointsToValue(edge, plotArea);",
            "",
            "// check for both bounds smaller than 1",
            "this.axis.setRange(0.2, 0.7);",
            "checkPointsToValue(edge, plotArea);",
            "}"
        ],
        "before_pmt": "val, <, 1.0,",
        "after_pmt": "val, !=, 1.0,",
        "mutator": "ROR",
        "mut_src_line_no": 6,
        "label": 1
    },
    {
        "mut_no": 26259,
        "test_method": "org.jfree.chart.plot.junit.IntervalMarkerTests.testCloning",
        "source_method": "<init>(double,double)",
        "src_lines": [
            "public IntervalMarker(double start, double end) {",
            "this(start, end, Color.gray, new BasicStroke(0.5f), Color.gray,",
            "new BasicStroke(0.5f), 0.8f);",
            "}"
        ],
        "new_line": "new BasicStroke(0.5f), -0.8f);",
        "tst_lines": [
            "public void testCloning() {",
            "IntervalMarker m1 = new IntervalMarker(45.0, 50.0);",
            "IntervalMarker m2 = null;",
            "try {",
            "m2 = (IntervalMarker) m1.clone();",
            "}",
            "catch (CloneNotSupportedException e) {",
            "e.printStackTrace();",
            "}",
            "assertTrue(m1 != m2);",
            "assertTrue(m1.getClass() == m2.getClass());",
            "assertTrue(m1.equals(m2));",
            "}"
        ],
        "before_pmt": "0.8F,",
        "after_pmt": "-, 0.8F,",
        "mutator": "LVR",
        "mut_src_line_no": 2,
        "label": 1
    },
    {
        "mut_no": 9159,
        "test_method": "org.apache.commons.lang3.text.StrBuilderTest.testDeleteFirst_char",
        "source_method": "deleteImpl(int,int,int)",
        "src_lines": [
            "private void deleteImpl(final int startIndex, final int endIndex, final int len) {",
            "System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);",
            "size -= len;",
            "}"
        ],
        "new_line": "System.arraycopy(buffer, endIndex, buffer, startIndex, size * endIndex);",
        "tst_lines": [
            "public void testDeleteFirst_char() {",
            "StrBuilder sb = new StrBuilder(\"abcba\");",
            "sb.deleteFirst('X');",
            "assertEquals(\"abcba\", sb.toString());",
            "sb.deleteFirst('a');",
            "assertEquals(\"bcba\", sb.toString());",
            "sb.deleteFirst('c');",
            "assertEquals(\"bba\", sb.toString());",
            "sb.deleteFirst('b');",
            "assertEquals(\"ba\", sb.toString());",
            "",
            "sb = new StrBuilder(\"\");",
            "sb.deleteFirst('b');",
            "assertEquals(\"\", sb.toString());",
            "}"
        ],
        "before_pmt": "size, -, endIndex,",
        "after_pmt": "size, *, endIndex,",
        "mutator": "AOR",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 979,
        "test_method": "org.apache.commons.csv.CSVParserTest.testGetLineNumberWithCR",
        "source_method": "readEndOfLine(int)",
        "src_lines": [
            "boolean readEndOfLine(int ch) throws IOException {",
            "// check if we have \\r\\n...",
            "if (ch == CR && reader.lookAhead() == LF) {",
            "// note: does not change ch outside of this method!",
            "ch = reader.read();",
            "// Save the EOL state",
            "if (firstEol == null) {",
            "this.firstEol = Constants.CRLF;",
            "}",
            "}",
            "// save EOL state here.",
            "if (firstEol == null) {",
            "if (ch == LF) {",
            "this.firstEol = LF_STRING;",
            "} else if (ch == CR) {",
            "this.firstEol = CR_STRING;",
            "}",
            "}",
            "",
            "return ch == LF || ch == CR;",
            "}"
        ],
        "new_line": "} else if (ch >= CR) {",
        "tst_lines": [
            "public void testGetLineNumberWithCR() throws Exception {",
            "this.validateLineNumbers(String.valueOf(CR));",
            "}"
        ],
        "before_pmt": "ch, ==, CR,",
        "after_pmt": "ch, >=, CR,",
        "mutator": "ROR",
        "mut_src_line_no": 14,
        "label": 0
    },
    {
        "mut_no": 25458,
        "test_method": "org.jfree.chart.plot.junit.PiePlotTests.testCloning",
        "source_method": "<init>()",
        "src_lines": [
            "public StrokeMap() {",
            "this.store = new TreeMap();",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testCloning() {",
            "PiePlot p1 = new PiePlot();",
            "PiePlot p2 = null;",
            "try {",
            "p2 = (PiePlot) p1.clone();",
            "}",
            "catch (CloneNotSupportedException e) {",
            "e.printStackTrace();",
            "}",
            "assertTrue(p1 != p2);",
            "assertTrue(p1.getClass() == p2.getClass());",
            "assertTrue(p1.equals(p2));",
            "}"
        ],
        "before_pmt": "this, ., store, =, new, TreeMap, (, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 4821,
        "test_method": "org.jfree.chart.junit.TimeSeriesChartTests.testDrawWithNullInfo",
        "source_method": "getRangeAxisLocation(int)",
        "src_lines": [
            "public AxisLocation getRangeAxisLocation(int index) {",
            "AxisLocation result = null;",
            "if (index < this.rangeAxisLocations.size()) {",
            "result = (AxisLocation) this.rangeAxisLocations.get(index);",
            "}",
            "if (result == null) {",
            "result = AxisLocation.getOpposite(getRangeAxisLocation());",
            "}",
            "return result;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testDrawWithNullInfo() {",
            "",
            "boolean success = false;",
            "try {",
            "BufferedImage image = new BufferedImage(200 , 100,",
            "BufferedImage.TYPE_INT_RGB);",
            "Graphics2D g2 = image.createGraphics();",
            "this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,",
            "null);",
            "g2.dispose();",
            "success = true;",
            "}",
            "catch (Exception e) {",
            "success = false;",
            "e.printStackTrace();",
            "}",
            "assertTrue(success);",
            "",
            "}"
        ],
        "before_pmt": "result, =, (, AxisLocation, ), this, ., rangeAxisLocations, ., get, (, index, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 3,
        "label": 0
    },
    {
        "mut_no": 3018,
        "test_method": "com.fasterxml.jackson.core.json.async.AsyncNumberLeadingZeroesTest.testLeadingZeroesInt",
        "source_method": "_calcTertiaryShift(int)",
        "src_lines": [
            "static int _calcTertiaryShift(int primarySlots)",
            "{",
            "// first: we only get 1/4 of slots of primary, to divide",
            "int tertSlots = (primarySlots) >> 2;",
            "",
            "// default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)",
            "if (tertSlots < 64) {",
            "return 4;",
            "}",
            "if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)",
            "return 5;",
            "}",
            "if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)",
            "return 6;",
            "}",
            "// and biggest buckets have 32 slots",
            "return 7;",
            "}"
        ],
        "new_line": "return 0;",
        "tst_lines": [
            "public void testLeadingZeroesInt() throws Exception",
            "{",
            "_testLeadingZeroesInt(\"00003\", 3);",
            "_testLeadingZeroesInt(\"00003 \", 3);",
            "_testLeadingZeroesInt(\" 00003\", 3);",
            "",
            "_testLeadingZeroesInt(\"-00007\", -7);",
            "_testLeadingZeroesInt(\"-00007 \", -7);",
            "_testLeadingZeroesInt(\" -00007\", -7);",
            "",
            "_testLeadingZeroesInt(\"056\", 56);",
            "_testLeadingZeroesInt(\"056 \", 56);",
            "_testLeadingZeroesInt(\" 056\", 56);",
            "",
            "_testLeadingZeroesInt(\"-04\", -4);",
            "_testLeadingZeroesInt(\"-04  \", -4);",
            "_testLeadingZeroesInt(\" -04\", -4);",
            "",
            "_testLeadingZeroesInt(\"0\"+Integer.MAX_VALUE, Integer.MAX_VALUE);",
            "_testLeadingZeroesInt(\" 0\"+Integer.MAX_VALUE, Integer.MAX_VALUE);",
            "_testLeadingZeroesInt(\"0\"+Integer.MAX_VALUE+\" \", Integer.MAX_VALUE);",
            "}"
        ],
        "before_pmt": "4,",
        "after_pmt": "0,",
        "mutator": "LVR",
        "mut_src_line_no": 7,
        "label": 0
    },
    {
        "mut_no": 11100,
        "test_method": "com.fasterxml.jackson.core.base64.Base64BinaryParsingTest.testOkMissingPadding",
        "source_method": "<init>(com.fasterxml.jackson.core.io.IOContext,int,java.io.Reader,com.fasterxml.jackson.core.ObjectCodec,com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer)",
        "src_lines": [
            "public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,",
            "ObjectCodec codec, CharsToNameCanonicalizer st)",
            "{",
            "super(ctxt, features);",
            "_reader = r;",
            "_inputBuffer = ctxt.allocTokenBuffer();",
            "_inputPtr = 0;",
            "_inputEnd = 0;",
            "_objectCodec = codec;",
            "_symbols = st;",
            "_hashSeed = st.hashSeed();",
            "_bufferRecyclable = true;",
            "}"
        ],
        "new_line": "_inputEnd = -1;",
        "tst_lines": [
            "public void testOkMissingPadding() throws IOException {",
            "final byte[] DOC1 = new byte[] { (byte) 0xAD };",
            "_testOkMissingPadding(DOC1, MODE_INPUT_STREAM);",
            "_testOkMissingPadding(DOC1, MODE_INPUT_STREAM_THROTTLED);",
            "_testOkMissingPadding(DOC1, MODE_READER);",
            "_testOkMissingPadding(DOC1, MODE_DATA_INPUT);",
            "",
            "final byte[] DOC2 = new byte[] { (byte) 0xAC, (byte) 0xDC };",
            "_testOkMissingPadding(DOC2, MODE_INPUT_STREAM);",
            "_testOkMissingPadding(DOC2, MODE_INPUT_STREAM_THROTTLED);",
            "_testOkMissingPadding(DOC2, MODE_READER);",
            "_testOkMissingPadding(DOC2, MODE_DATA_INPUT);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 7,
        "label": 0
    },
    {
        "mut_no": 21326,
        "test_method": "org.apache.commons.lang3.time.FastDatePrinterTest.testLang645",
        "source_method": "init()",
        "src_lines": [
            "private void init() {",
            "final Calendar definingCalendar = Calendar.getInstance(timeZone, locale);",
            "thisYear= definingCalendar.get(Calendar.YEAR);",
            "",
            "final StringBuilder regex= new StringBuilder();",
            "final List<Strategy> collector = new ArrayList<Strategy>();",
            "",
            "final Matcher patternMatcher= formatPattern.matcher(pattern);",
            "if(!patternMatcher.lookingAt()) {",
            "throw new IllegalArgumentException(",
            "\"Illegal pattern character '\" + pattern.charAt(patternMatcher.regionStart()) + \"'\");",
            "}",
            "",
            "currentFormatField= patternMatcher.group();",
            "Strategy currentStrategy= getStrategy(currentFormatField, definingCalendar);",
            "for(;;) {",
            "patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());",
            "if(!patternMatcher.lookingAt()) {",
            "nextStrategy = null;",
            "break;",
            "}",
            "final String nextFormatField= patternMatcher.group();",
            "nextStrategy = getStrategy(nextFormatField, definingCalendar);",
            "if(currentStrategy.addRegex(this, regex)) {",
            "collector.add(currentStrategy);",
            "}",
            "currentFormatField= nextFormatField;",
            "currentStrategy= nextStrategy;",
            "}",
            "if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {",
            "throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());",
            "}",
            "if(currentStrategy.addRegex(this, regex)) {",
            "collector.add(currentStrategy);",
            "}",
            "currentFormatField= null;",
            "strategies= collector.toArray(new Strategy[collector.size()]);",
            "parsePattern= Pattern.compile(regex.toString());",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testLang645() {",
            "final Locale locale = new Locale(\"sv\", \"SE\");",
            "",
            "final Calendar cal = Calendar.getInstance();",
            "cal.set(2010, 0, 1, 12, 0, 0);",
            "final Date d = cal.getTime();",
            "",
            "final DatePrinter fdf = getInstance(\"EEEE', week 'ww\", locale);",
            "",
            "assertEquals(\"fredag, week 53\", fdf.format(d));",
            "}"
        ],
        "before_pmt": "patternMatcher, ., regionStart, (, ), !=, patternMatcher, ., regionEnd, (, ),",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 29,
        "label": 0
    },
    {
        "mut_no": 4011,
        "test_method": "com.google.gson.functional.CustomDeserializerTest.testJsonTypeFieldBasedDeserialization",
        "source_method": "skipValue()",
        "src_lines": [
            "@Override public void skipValue() throws IOException {",
            "if (peek() == JsonToken.NAME) {",
            "nextName();",
            "pathNames[stackSize - 2] = \"null\";",
            "} else {",
            "popStack();",
            "if (stackSize > 0) {",
            "pathNames[stackSize - 1] = \"null\";",
            "}",
            "}",
            "if (stackSize > 0) {",
            "pathIndices[stackSize - 1]++;",
            "}",
            "}"
        ],
        "new_line": "if (stackSize >= 0) {",
        "tst_lines": [
            "public void testJsonTypeFieldBasedDeserialization() {",
            "String json = \"{field1:'abc',field2:'def',__type__:'SUB_TYPE1'}\";",
            "Gson gson = new GsonBuilder().registerTypeAdapter(MyBase.class, new JsonDeserializer<MyBase>() {",
            "@Override public MyBase deserialize(JsonElement json, Type pojoType,",
            "JsonDeserializationContext context) throws JsonParseException {",
            "String type = json.getAsJsonObject().get(MyBase.TYPE_ACCESS).getAsString();",
            "return context.deserialize(json, SubTypes.valueOf(type).getSubclass());",
            "}",
            "}).create();",
            "SubType1 target = (SubType1) gson.fromJson(json, MyBase.class);",
            "assertEquals(\"abc\", target.field1);",
            "}"
        ],
        "before_pmt": "stackSize, >, 0,",
        "after_pmt": "stackSize, >=, 0,",
        "mutator": "ROR",
        "mut_src_line_no": 6,
        "label": 0
    },
    {
        "mut_no": 66358,
        "test_method": "org.jfree.chart.renderer.category.junit.BoxAndWhiskerRendererTests.testDrawWithNullMaxRegular",
        "source_method": "createTranslatedShape(java.awt.Shape,org.jfree.chart.util.RectangleAnchor,double,double)",
        "src_lines": [
            "public static Shape createTranslatedShape(Shape shape,",
            "RectangleAnchor anchor,",
            "double locationX,",
            "double locationY) {",
            "if (shape == null) {",
            "throw new IllegalArgumentException(\"Null 'shape' argument.\");",
            "}",
            "if (anchor == null) {",
            "throw new IllegalArgumentException(\"Null 'anchor' argument.\");",
            "}",
            "Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),",
            "anchor);",
            "AffineTransform transform = AffineTransform.getTranslateInstance(",
            "locationX - anchorPoint.getX(), locationY - anchorPoint.getY());",
            "return transform.createTransformedShape(shape);",
            "}"
        ],
        "new_line": "locationX - anchorPoint.getX(), locationY % anchorPoint.getY());",
        "tst_lines": [
            "public void testDrawWithNullMaxRegular() {",
            "boolean success = false;",
            "try {",
            "DefaultBoxAndWhiskerCategoryDataset dataset",
            "= new DefaultBoxAndWhiskerCategoryDataset();",
            "dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0),",
            "new Double(3.0), new Double(4.0), new Double(0.5),",
            "null, new Double(-0.5), new Double(5.5),",
            "null), \"S1\", \"C1\");",
            "CategoryPlot plot = new CategoryPlot(dataset,",
            "new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
            "new BoxAndWhiskerRenderer());",
            "ChartRenderingInfo info = new ChartRenderingInfo();",
            "JFreeChart chart = new JFreeChart(plot);",
            "/* BufferedImage image = */ chart.createBufferedImage(300, 200,",
            "info);",
            "success = true;",
            "}",
            "catch (Exception e) {",
            "success = false;",
            "}",
            "assertTrue(success);",
            "}"
        ],
        "before_pmt": "locationY, -, anchorPoint, ., getY, (, ),",
        "after_pmt": "locationY, %, anchorPoint, ., getY, (, ),",
        "mutator": "AOR",
        "mut_src_line_no": 13,
        "label": 0
    },
    {
        "mut_no": 2599,
        "test_method": "com.google.gson.functional.StringTest.testSingleQuoteInStringSerialization",
        "source_method": "newJsonWriter(java.io.Writer)",
        "src_lines": [
            "public JsonWriter newJsonWriter(Writer writer) throws IOException {",
            "if (generateNonExecutableJson) {",
            "writer.write(JSON_NON_EXECUTABLE_PREFIX);",
            "}",
            "JsonWriter jsonWriter = new JsonWriter(writer);",
            "if (prettyPrinting) {",
            "jsonWriter.setIndent(\"  \");",
            "}",
            "jsonWriter.setSerializeNulls(serializeNulls);",
            "return jsonWriter;",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testSingleQuoteInStringSerialization() throws Exception {",
            "String valueWithQuotes = \"beforeQuote'afterQuote\";",
            "String jsonRepresentation = gson.toJson(valueWithQuotes);",
            "assertEquals(valueWithQuotes, gson.fromJson(jsonRepresentation, String.class));",
            "}"
        ],
        "before_pmt": "generateNonExecutableJson,",
        "after_pmt": "true,",
        "mutator": "COR",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 392,
        "test_method": "com.google.gson.functional.PrimitiveTest.testDoubleArrayDeserialization",
        "source_method": "hasNext()",
        "src_lines": [
            "public boolean hasNext() throws IOException {",
            "int p = peeked;",
            "if (p == PEEKED_NONE) {",
            "p = doPeek();",
            "}",
            "return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;",
            "}"
        ],
        "new_line": "return true && p != PEEKED_END_ARRAY;",
        "tst_lines": [
            "public void testDoubleArrayDeserialization() {",
            "String json = \"[0.0, 0.004761904761904762, 3.4013606962703525E-4, 7.936508173034305E-4,\"",
            "+ \"0.0011904761904761906, 0.0]\";",
            "double[] values = gson.fromJson(json, double[].class);",
            "assertEquals(6, values.length);",
            "assertEquals(0.0, values[0]);",
            "assertEquals(0.004761904761904762, values[1]);",
            "assertEquals(3.4013606962703525E-4, values[2]);",
            "assertEquals(7.936508173034305E-4, values[3]);",
            "assertEquals(0.0011904761904761906, values[4]);",
            "assertEquals(0.0, values[5]);",
            "}"
        ],
        "before_pmt": "p, !=, PEEKED_END_OBJECT,",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 5,
        "label": 0
    },
    {
        "mut_no": 3765,
        "test_method": "com.google.gson.functional.PrimitiveTest.testStringsAsBooleans",
        "source_method": "create(com.google.gson.Gson,com.google.gson.reflect.TypeToken<T>)",
        "src_lines": [
            "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {",
            "Type type = typeToken.getType();",
            "",
            "Class<? super T> rawType = typeToken.getRawType();",
            "if (!Collection.class.isAssignableFrom(rawType)) {",
            "return null;",
            "}",
            "",
            "Type elementType = $Gson$Types.getCollectionElementType(type, rawType);",
            "TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));",
            "ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);",
            "",
            "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter",
            "TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);",
            "return result;",
            "}"
        ],
        "new_line": "if (!true) {",
        "tst_lines": [
            "public void testStringsAsBooleans() {",
            "String json = \"['true', 'false', 'TRUE', 'yes', '1']\";",
            "assertEquals(Arrays.asList(true, false, true, false, false),",
            "gson.<List<Boolean>>fromJson(json, new TypeToken<List<Boolean>>() {}.getType()));",
            "}"
        ],
        "before_pmt": "Collection, ., class, ., isAssignableFrom, (, rawType, ),",
        "after_pmt": "true,",
        "mutator": "COR",
        "mut_src_line_no": 4,
        "label": 0
    },
    {
        "mut_no": 1019,
        "test_method": "org.apache.commons.csv.CSVParserTest.testDefaultFormat",
        "source_method": "isEscape(int)",
        "src_lines": [
            "boolean isEscape(final int ch) {",
            "return ch == escape;",
            "}"
        ],
        "new_line": "return ch <= escape;",
        "tst_lines": [
            "public void testDefaultFormat() throws IOException {",
            "final String code = \"\" + \"a,b#\\n\" // 1)",
            "+ \"\\\"\\n\\\",\\\" \\\",#\\n\" // 2)",
            "+ \"#,\\\"\\\"\\n\" // 3)",
            "+ \"# Final comment\\n\"// 4)",
            ";",
            "final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };",
            "",
            "CSVFormat format = CSVFormat.DEFAULT;",
            "assertFalse(format.isCommentMarkerSet());",
            "final String[][] res_comments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, };",
            "",
            "try (final CSVParser parser = CSVParser.parse(code, format)) {",
            "final List<CSVRecord> records = parser.getRecords();",
            "assertTrue(records.size() > 0);",
            "",
            "Utils.compare(\"Failed to parse without comments\", res, records);",
            "",
            "format = CSVFormat.DEFAULT.withCommentMarker('#');",
            "}",
            "try (final CSVParser parser = CSVParser.parse(code, format)) {",
            "final List<CSVRecord> records = parser.getRecords();",
            "",
            "Utils.compare(\"Failed to parse with comments\", res_comments, records);",
            "}",
            "}"
        ],
        "before_pmt": "ch, ==, escape,",
        "after_pmt": "ch, <=, escape,",
        "mutator": "ROR",
        "mut_src_line_no": 1,
        "label": 1
    },
    {
        "mut_no": 22334,
        "test_method": "com.fasterxml.jackson.core.main.TestParserWithObjects.testNextValue",
        "source_method": "_skipWS()",
        "src_lines": [
            "private final int _skipWS() throws IOException",
            "{",
            "while (_inputPtr < _inputEnd) {",
            "int i = _inputBuffer[_inputPtr++] & 0xFF;",
            "if (i > INT_SPACE) {",
            "if (i == INT_SLASH || i == INT_HASH) {",
            "--_inputPtr;",
            "return _skipWS2();",
            "}",
            "return i;",
            "}",
            "if (i != INT_SPACE) {",
            "if (i == INT_LF) {",
            "++_currInputRow;",
            "_currInputRowStart = _inputPtr;",
            "} else if (i == INT_CR) {",
            "_skipCR();",
            "} else if (i != INT_TAB) {",
            "_throwInvalidSpace(i);",
            "}",
            "}",
            "}",
            "return _skipWS2();",
            "}"
        ],
        "new_line": "if (i >= INT_SPACE) {",
        "tst_lines": [
            "public void testNextValue() throws IOException",
            "{",
            "// Let's test both byte-backed and Reader-based one",
            "_testNextValueBasic(false);",
            "_testNextValueBasic(true);",
            "}"
        ],
        "before_pmt": "i, >, INT_SPACE,",
        "after_pmt": "i, >=, INT_SPACE,",
        "mutator": "ROR",
        "mut_src_line_no": 4,
        "label": 1
    },
    {
        "mut_no": 4025,
        "test_method": "com.fasterxml.jackson.core.read.NumberOverflowTest.testSimpleLongOverflow",
        "source_method": "getTextOffset()",
        "src_lines": [
            "public int getTextOffset() {",
            "/* Only shared input buffer can have non-zero offset; buffer",
            "* segments start at 0, and if we have to create a combo buffer,",
            "* that too will start from beginning of the buffer",
            "*/",
            "return (_inputStart >= 0) ? _inputStart : 0;",
            "}"
        ],
        "new_line": "return (_inputStart >= 1) ? _inputStart : 0;",
        "tst_lines": [
            "public void testSimpleLongOverflow() throws Exception",
            "{",
            "BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);",
            "below = below.subtract(BigInteger.ONE);",
            "BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);",
            "above = above.add(BigInteger.ONE);",
            "",
            "String DOC_BELOW = below.toString() + \" \";",
            "String DOC_ABOVE = below.toString() + \" \";",
            "",
            "for (int mode : ALL_MODES) {",
            "JsonParser p = createParser(FACTORY, mode, DOC_BELOW);",
            "p.nextToken();",
            "try {",
            "long x = p.getLongValue();",
            "fail(\"Expected an exception for underflow (input \"+p.getText()+\"): instead, got long value: \"+x);",
            "} catch (JsonParseException e) {",
            "verifyException(e, \"out of range of long\");",
            "}",
            "p.close();",
            "",
            "p = createParser(mode, DOC_ABOVE);",
            "p.nextToken();",
            "try {",
            "long x = p.getLongValue();",
            "fail(\"Expected an exception for underflow (input \"+p.getText()+\"): instead, got long value: \"+x);",
            "} catch (JsonParseException e) {",
            "verifyException(e, \"out of range of long\");",
            "}",
            "p.close();",
            "}",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "1,",
        "mutator": "LVR",
        "mut_src_line_no": 5,
        "label": 1
    },
    {
        "mut_no": 866,
        "test_method": "com.google.gson.functional.MapTest.testDeerializeMapOfMaps",
        "source_method": "nextString()",
        "src_lines": [
            "public String nextString() throws IOException {",
            "int p = peeked;",
            "if (p == PEEKED_NONE) {",
            "p = doPeek();",
            "}",
            "String result;",
            "if (p == PEEKED_UNQUOTED) {",
            "result = nextUnquotedValue();",
            "} else if (p == PEEKED_SINGLE_QUOTED) {",
            "result = nextQuotedValue('\\'');",
            "} else if (p == PEEKED_DOUBLE_QUOTED) {",
            "result = nextQuotedValue('\"');",
            "} else if (p == PEEKED_BUFFERED) {",
            "result = peekedString;",
            "peekedString = null;",
            "} else if (p == PEEKED_LONG) {",
            "result = Long.toString(peekedLong);",
            "} else if (p == PEEKED_NUMBER) {",
            "result = new String(buffer, pos, peekedNumberLength);",
            "pos += peekedNumberLength;",
            "} else {",
            "throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());",
            "}",
            "peeked = PEEKED_NONE;",
            "pathIndices[stackSize - 1]++;",
            "return result;",
            "}"
        ],
        "new_line": "if (p >= PEEKED_UNQUOTED) {",
        "tst_lines": [
            "public void testDeerializeMapOfMaps() {",
            "Type type = new TypeToken<Map<String, Map<String, String>>>() {}.getType();",
            "Map<String, Map<String, String>> map = newMap(",
            "\"a\", newMap(\"ka1\", \"va1\", \"ka2\", \"va2\"),",
            "\"b\", newMap(\"kb1\", \"vb1\", \"kb2\", \"vb2\"));",
            "String json = \"{'a':{'ka1':'va1','ka2':'va2'},'b':{'kb1':'vb1','kb2':'vb2'}}\";",
            "assertEquals(map, gson.fromJson(json, type));",
            "}"
        ],
        "before_pmt": "p, ==, PEEKED_UNQUOTED,",
        "after_pmt": "p, >=, PEEKED_UNQUOTED,",
        "mutator": "ROR",
        "mut_src_line_no": 6,
        "label": 0
    },
    {
        "mut_no": 7875,
        "test_method": "org.jfree.chart.junit.LineChartTests.testDrawWithNullInfo",
        "source_method": "<init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean,java.awt.Shape,boolean,java.awt.Paint,boolean,java.awt.Paint,java.awt.Stroke,boolean,java.awt.Shape,java.awt.Stroke,java.awt.Paint)",
        "src_lines": [
            "public LegendItem(String label, String description,",
            "String toolTipText, String urlText,",
            "boolean shapeVisible, Shape shape,",
            "boolean shapeFilled, Paint fillPaint,",
            "boolean shapeOutlineVisible, Paint outlinePaint,",
            "Stroke outlineStroke,",
            "boolean lineVisible, Shape line,",
            "Stroke lineStroke, Paint linePaint) {",
            "",
            "if (label == null) {",
            "throw new IllegalArgumentException(\"Null 'label' argument.\");",
            "}",
            "if (fillPaint == null) {",
            "throw new IllegalArgumentException(\"Null 'fillPaint' argument.\");",
            "}",
            "if (lineStroke == null) {",
            "throw new IllegalArgumentException(\"Null 'lineStroke' argument.\");",
            "}",
            "if (outlinePaint == null) {",
            "throw new IllegalArgumentException(\"Null 'outlinePaint' argument.\");",
            "}",
            "if (outlineStroke == null) {",
            "throw new IllegalArgumentException(",
            "\"Null 'outlineStroke' argument.\");",
            "}",
            "this.label = label;",
            "this.labelPaint = null;",
            "this.attributedLabel = null;",
            "this.description = description;",
            "this.shapeVisible = shapeVisible;",
            "this.shape = shape;",
            "this.shapeFilled = shapeFilled;",
            "this.fillPaint = fillPaint;",
            "this.fillPaintTransformer = new StandardGradientPaintTransformer();",
            "this.shapeOutlineVisible = shapeOutlineVisible;",
            "this.outlinePaint = outlinePaint;",
            "this.outlineStroke = outlineStroke;",
            "this.lineVisible = lineVisible;",
            "this.line = line;",
            "this.lineStroke = lineStroke;",
            "this.linePaint = linePaint;",
            "this.toolTipText = toolTipText;",
            "this.urlText = urlText;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testDrawWithNullInfo() {",
            "",
            "boolean success = false;",
            "try {",
            "BufferedImage image = new BufferedImage(200 , 100,",
            "BufferedImage.TYPE_INT_RGB);",
            "Graphics2D g2 = image.createGraphics();",
            "this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null,",
            "null);",
            "g2.dispose();",
            "success = true;",
            "}",
            "catch (Exception e) {",
            "success = false;",
            "}",
            "assertTrue(success);",
            "",
            "}"
        ],
        "before_pmt": "this, ., fillPaint, =, fillPaint,",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 32,
        "label": 1
    },
    {
        "mut_no": 4370,
        "test_method": "com.google.gson.functional.CustomDeserializerTest.testCustomDeserializerReturnsNullForArrayElementsForArrayField",
        "source_method": "create(com.google.gson.Gson,com.google.gson.reflect.TypeToken<T>)",
        "src_lines": [
            "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {",
            "boolean matches = exactType != null",
            "? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()",
            ": hierarchyType.isAssignableFrom(type.getRawType());",
            "return matches",
            "? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,",
            "(JsonDeserializer<T>) deserializer, gson, type, this)",
            ": null;",
            "}"
        ],
        "new_line": "? exactType.equals(type) || false",
        "tst_lines": [
            "public void testCustomDeserializerReturnsNullForArrayElementsForArrayField() {",
            "Gson gson = new GsonBuilder()",
            ".registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {",
            "@Override",
            "public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)",
            "throws JsonParseException {",
            "return null;",
            "}",
            "}).create();",
            "String json = \"{bases:[{baseName:'Base'},{baseName:'Base'}]}\";",
            "ClassWithBaseArray target = gson.fromJson(json, ClassWithBaseArray.class);",
            "assertNull(target.bases[0]);",
            "assertNull(target.bases[1]);",
            "}"
        ],
        "before_pmt": "matchRawType, &&, exactType, ., getType, (, ), ==, type, ., getRawType, (, ),",
        "after_pmt": "false,",
        "mutator": "COR",
        "mut_src_line_no": 2,
        "label": 0
    },
    {
        "mut_no": 77593,
        "test_method": "org.jfree.data.time.junit.MillisecondTests.testGetStart",
        "source_method": "<init>(int,int,int)",
        "src_lines": [
            "public SpreadsheetDate(final int day, final int month, final int year) {",
            "",
            "if ((year >= 1900) && (year <= 9999)) {",
            "this.year = year;",
            "}",
            "else {",
            "throw new IllegalArgumentException(",
            "\"The 'year' argument must be in range 1900 to 9999.\"",
            ");",
            "}",
            "",
            "if ((month >= MonthConstants.JANUARY)",
            "&& (month <= MonthConstants.DECEMBER)) {",
            "this.month = month;",
            "}",
            "else {",
            "throw new IllegalArgumentException(",
            "\"The 'month' argument must be in the range 1 to 12.\"",
            ");",
            "}",
            "",
            "if ((day >= 1) && (day <= SerialDate.lastDayOfMonth(month, year))) {",
            "this.day = day;",
            "}",
            "else {",
            "throw new IllegalArgumentException(\"Invalid 'day' argument.\");",
            "}",
            "",
            "// the serial number needs to be synchronised with the day-month-year...",
            "this.serial = calcSerial(day, month, year);",
            "",
            "}"
        ],
        "new_line": "if ((day >= 1) && (day == SerialDate.lastDayOfMonth(month, year))) {",
        "tst_lines": [
            "public void testGetStart() {",
            "Locale saved = Locale.getDefault();",
            "Locale.setDefault(Locale.ITALY);",
            "Calendar cal = Calendar.getInstance(Locale.ITALY);",
            "cal.set(2006, Calendar.JANUARY, 16, 3, 47, 55);",
            "cal.set(Calendar.MILLISECOND, 555);",
            "Millisecond m = new Millisecond(555, 55, 47, 3, 16, 1, 2006);",
            "assertEquals(cal.getTime(), m.getStart());",
            "Locale.setDefault(saved);",
            "}"
        ],
        "before_pmt": "day, <=, SerialDate, ., lastDayOfMonth, (, month, ,, year, ),",
        "after_pmt": "day, ==, SerialDate, ., lastDayOfMonth, (, month, ,, year, ),",
        "mutator": "ROR",
        "mut_src_line_no": 21,
        "label": 1
    },
    {
        "mut_no": 11159,
        "test_method": "com.fasterxml.jackson.core.read.CommentParsingTest.testCommentsWithUTF8",
        "source_method": "_loadMore()",
        "src_lines": [
            "protected boolean _loadMore() throws IOException",
            "{",
            "final int bufSize = _inputEnd;",
            "",
            "_currInputProcessed += bufSize;",
            "_currInputRowStart -= bufSize;",
            "",
            "// 26-Nov-2015, tatu: Since name-offset requires it too, must offset",
            "//   this increase to avoid \"moving\" name-offset, resulting most likely",
            "//   in negative value, which is fine as combine value remains unchanged.",
            "_nameStartOffset -= bufSize;",
            "",
            "if (_reader != null) {",
            "int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);",
            "if (count > 0) {",
            "_inputPtr = 0;",
            "_inputEnd = count;",
            "return true;",
            "}",
            "// End of input",
            "_closeInput();",
            "// Should never return 0, so let's fail",
            "if (count == 0) {",
            "throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);",
            "}",
            "}",
            "return false;",
            "}"
        ],
        "new_line": "if (count == -1) {",
        "tst_lines": [
            "public void testCommentsWithUTF8() throws Exception",
            "{",
            "final String JSON = \"/* \\u00a9 2099 Yoyodyne Inc. */\\n [ \\\"bar? \\u00a9\\\" ]\\n\";",
            "_testWithUTF8Chars(JSON, MODE_INPUT_STREAM);",
            "_testWithUTF8Chars(JSON, MODE_INPUT_STREAM_THROTTLED);",
            "_testWithUTF8Chars(JSON, MODE_READER);",
            "_testWithUTF8Chars(JSON, MODE_DATA_INPUT);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 22,
        "label": 1
    },
    {
        "mut_no": 2770,
        "test_method": "com.google.gson.functional.CustomDeserializerTest.testCustomDeserializerReturnsNull",
        "source_method": "excludeField(java.lang.reflect.Field,boolean)",
        "src_lines": [
            "public boolean excludeField(Field field, boolean serialize) {",
            "if ((modifiers & field.getModifiers()) != 0) {",
            "return true;",
            "}",
            "",
            "if (version != Excluder.IGNORE_VERSIONS",
            "&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {",
            "return true;",
            "}",
            "",
            "if (field.isSynthetic()) {",
            "return true;",
            "}",
            "",
            "if (requireExpose) {",
            "Expose annotation = field.getAnnotation(Expose.class);",
            "if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {",
            "return true;",
            "}",
            "}",
            "",
            "if (!serializeInnerClasses && isInnerClass(field.getType())) {",
            "return true;",
            "}",
            "",
            "if (isAnonymousOrLocal(field.getType())) {",
            "return true;",
            "}",
            "",
            "List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;",
            "if (!list.isEmpty()) {",
            "FieldAttributes fieldAttributes = new FieldAttributes(field);",
            "for (ExclusionStrategy exclusionStrategy : list) {",
            "if (exclusionStrategy.shouldSkipField(fieldAttributes)) {",
            "return true;",
            "}",
            "}",
            "}",
            "",
            "return false;",
            "}"
        ],
        "new_line": "if ((modifiers & field.getModifiers()) != -1) {",
        "tst_lines": [
            "public void testCustomDeserializerReturnsNull() {",
            "Gson gson = new GsonBuilder()",
            ".registerTypeAdapter(Base.class, new JsonDeserializer<Base>() {",
            "@Override",
            "public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)",
            "throws JsonParseException {",
            "return null;",
            "}",
            "}).create();",
            "String json = \"{base:{baseName:'Base',subName:'SubRevised'}}\";",
            "ClassWithBaseField target = gson.fromJson(json, ClassWithBaseField.class);",
            "assertNull(target.base);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 1399,
        "test_method": "org.jfree.chart.block.junit.BlockBorderTests.testEquals",
        "source_method": "<init>(org.jfree.chart.util.UnitType,double,double,double,double)",
        "src_lines": [
            "public RectangleInsets(UnitType unitType, double top, double left,",
            "double bottom, double right) {",
            "if (unitType == null) {",
            "throw new IllegalArgumentException(\"Null 'unitType' argument.\");",
            "}",
            "this.unitType = unitType;",
            "this.top = top;",
            "this.bottom = bottom;",
            "this.left = left;",
            "this.right = right;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testEquals() {",
            "BlockBorder b1 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0,",
            "4.0), Color.red);",
            "BlockBorder b2 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0,",
            "4.0), Color.red);",
            "assertTrue(b1.equals(b2));",
            "assertTrue(b2.equals(b2));",
            "",
            "// insets",
            "b1 = new BlockBorder(new RectangleInsets(UnitType.RELATIVE, 1.0, 2.0,",
            "3.0, 4.0), Color.red);",
            "assertFalse(b1.equals(b2));",
            "b2 = new BlockBorder(new RectangleInsets(UnitType.RELATIVE, 1.0, 2.0,",
            "3.0, 4.0), Color.red);",
            "assertTrue(b1.equals(b2));",
            "",
            "// paint",
            "b1 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0, 4.0),",
            "Color.blue);",
            "assertFalse(b1.equals(b2));",
            "b2 = new BlockBorder(new RectangleInsets(1.0, 2.0, 3.0, 4.0),",
            "Color.blue);",
            "assertTrue(b1.equals(b2));",
            "}"
        ],
        "before_pmt": "this, ., left, =, left,",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 8,
        "label": 0
    },
    {
        "mut_no": 2599,
        "test_method": "com.google.gson.functional.ObjectTest.testStringFieldWithEmptyValueSerialization",
        "source_method": "newJsonWriter(java.io.Writer)",
        "src_lines": [
            "public JsonWriter newJsonWriter(Writer writer) throws IOException {",
            "if (generateNonExecutableJson) {",
            "writer.write(JSON_NON_EXECUTABLE_PREFIX);",
            "}",
            "JsonWriter jsonWriter = new JsonWriter(writer);",
            "if (prettyPrinting) {",
            "jsonWriter.setIndent(\"  \");",
            "}",
            "jsonWriter.setSerializeNulls(serializeNulls);",
            "return jsonWriter;",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testStringFieldWithEmptyValueSerialization() {",
            "ClassWithEmptyStringFields target = new ClassWithEmptyStringFields();",
            "target.a = \"5794749\";",
            "String json = gson.toJson(target);",
            "assertTrue(json.contains(\"\\\"a\\\":\\\"5794749\\\"\"));",
            "assertTrue(json.contains(\"\\\"b\\\":\\\"\\\"\"));",
            "assertTrue(json.contains(\"\\\"c\\\":\\\"\\\"\"));",
            "}"
        ],
        "before_pmt": "generateNonExecutableJson,",
        "after_pmt": "true,",
        "mutator": "COR",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 1471,
        "test_method": "com.google.gson.functional.EnumTest.testEnumSet",
        "source_method": "fillBuffer(int)",
        "src_lines": [
            "private boolean fillBuffer(int minimum) throws IOException {",
            "char[] buffer = this.buffer;",
            "lineStart -= pos;",
            "if (limit != pos) {",
            "limit -= pos;",
            "System.arraycopy(buffer, pos, buffer, 0, limit);",
            "} else {",
            "limit = 0;",
            "}",
            "",
            "pos = 0;",
            "int total;",
            "while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {",
            "limit += total;",
            "",
            "// if this is the first read, consume an optional byte order mark (BOM) if it exists",
            "if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {",
            "pos++;",
            "lineStart++;",
            "minimum++;",
            "}",
            "",
            "if (limit >= minimum) {",
            "return true;",
            "}",
            "}",
            "return false;",
            "}"
        ],
        "new_line": "if (lineNumber == -1 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {",
        "tst_lines": [
            "public void testEnumSet() {",
            "EnumSet<Roshambo> foo = EnumSet.of(Roshambo.ROCK, Roshambo.PAPER);",
            "String json = gson.toJson(foo);",
            "Type type = new TypeToken<EnumSet<Roshambo>>() {}.getType();",
            "EnumSet<Roshambo> bar = gson.fromJson(json, type);",
            "assertTrue(bar.contains(Roshambo.ROCK));",
            "assertTrue(bar.contains(Roshambo.PAPER));",
            "assertFalse(bar.contains(Roshambo.SCISSORS));",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 16,
        "label": 1
    },
    {
        "mut_no": 108,
        "test_method": "com.google.gson.functional.RawSerializationTest.testCollectionOfObjects",
        "source_method": "peek()",
        "src_lines": [
            "private int peek() {",
            "if (stackSize == 0) {",
            "throw new IllegalStateException(\"JsonWriter is closed.\");",
            "}",
            "return stack[stackSize - 1];",
            "}"
        ],
        "new_line": "if (stackSize == 1) {",
        "tst_lines": [
            "public void testCollectionOfObjects() {",
            "Collection<Foo> foos = Arrays.asList(new Foo(1), new Foo(2));",
            "String json = gson.toJson(foos);",
            "assertEquals(\"[{\\\"b\\\":1},{\\\"b\\\":2}]\", json);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "1,",
        "mutator": "LVR",
        "mut_src_line_no": 1,
        "label": 1
    },
    {
        "mut_no": 21375,
        "test_method": "org.apache.commons.lang3.time.FastDateParserTest.testLocales_ShortNoEra_AD",
        "source_method": "parse(java.lang.String,java.text.ParsePosition)",
        "src_lines": [
            "public Date parse(final String source, final ParsePosition pos) {",
            "final int offset= pos.getIndex();",
            "final Matcher matcher= parsePattern.matcher(source.substring(offset));",
            "if(!matcher.lookingAt()) {",
            "return null;",
            "}",
            "// timing tests indicate getting new instance is 19% faster than cloning",
            "final Calendar cal= Calendar.getInstance(timeZone, locale);",
            "cal.clear();",
            "",
            "for(int i=0; i<strategies.length;) {",
            "final Strategy strategy= strategies[i++];",
            "strategy.setCalendar(this, cal, matcher.group(i));",
            "}",
            "pos.setIndex(offset+matcher.end());",
            "return cal.getTime();",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testLocales_ShortNoEra_AD() throws Exception {",
            "testLocales(SHORT_FORMAT_NOERA, false);",
            "}"
        ],
        "before_pmt": "cal, ., clear, (, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 8,
        "label": 1
    },
    {
        "mut_no": 20605,
        "test_method": "org.apache.commons.lang3.time.FastDateParserTest.testShortDateStyleWithLocales",
        "source_method": "getPatternForStyle(java.lang.Integer,java.lang.Integer,java.util.Locale)",
        "src_lines": [
            "static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {",
            "final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);",
            "",
            "String pattern = cDateTimeInstanceCache.get(key);",
            "if (pattern == null) {",
            "try {",
            "DateFormat formatter;",
            "if (dateStyle == null) {",
            "formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);",
            "}",
            "else if (timeStyle == null) {",
            "formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);",
            "}",
            "else {",
            "formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);",
            "}",
            "pattern = ((SimpleDateFormat)formatter).toPattern();",
            "final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);",
            "if (previous != null) {",
            "// even though it doesn't matter if another thread put the pattern",
            "// it's still good practice to return the String instance that is",
            "// actually in the ConcurrentMap",
            "pattern= previous;",
            "}",
            "} catch (final ClassCastException ex) {",
            "throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);",
            "}",
            "}",
            "return pattern;",
            "}"
        ],
        "new_line": "else if (false) {",
        "tst_lines": [
            "public void testShortDateStyleWithLocales() throws ParseException {",
            "DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);",
            "final Calendar cal = Calendar.getInstance();",
            "cal.clear();",
            "",
            "cal.set(2004, 1, 3);",
            "assertEquals(cal.getTime(), fdf.parse(\"2/3/04\"));",
            "",
            "fdf = getDateInstance(FastDateFormat.SHORT, SWEDEN);",
            "assertEquals(cal.getTime(), fdf.parse(\"2004-02-03\"));",
            "}"
        ],
        "before_pmt": "timeStyle, ==, null,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 10,
        "label": 1
    },
    {
        "mut_no": 11164,
        "test_method": "com.fasterxml.jackson.core.read.NumberParsingTest.testLongerFloatingPoint",
        "source_method": "getText()",
        "src_lines": [
            "public final String getText() throws IOException",
            "{",
            "JsonToken t = _currToken;",
            "if (t == JsonToken.VALUE_STRING) {",
            "if (_tokenIncomplete) {",
            "_tokenIncomplete = false;",
            "_finishString(); // only strings can be incomplete",
            "}",
            "return _textBuffer.contentsAsString();",
            "}",
            "return _getText2(t);",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testLongerFloatingPoint() throws Exception",
            "{",
            "StringBuilder input = new StringBuilder();",
            "for (int i = 1; i < 201; i++) {",
            "input.append(1);",
            "}",
            "input.append(\".0\");",
            "final String DOC = input.toString();",
            "",
            "// test out with both Reader and ByteArrayInputStream",
            "JsonParser p;",
            "",
            "p = FACTORY.createParser(new StringReader(DOC));",
            "_testLongerFloat(p, DOC);",
            "p.close();",
            "",
            "p = FACTORY.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")));",
            "_testLongerFloat(p, DOC);",
            "p.close();",
            "}"
        ],
        "before_pmt": "t, ==, JsonToken, ., VALUE_STRING,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 0
    },
    {
        "mut_no": 20193,
        "test_method": "com.fasterxml.jackson.core.read.NextXxxAccessTest.testNextLongValue",
        "source_method": "_parseNumber2(char[],int,boolean,int)",
        "src_lines": [
            "private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,",
            "int intPartLength) throws IOException",
            "{",
            "// Ok, parse the rest",
            "while (true) {",
            "if (_inputPtr >= _inputEnd && !_loadMore()) {",
            "_textBuffer.setCurrentLength(outPtr);",
            "return resetInt(negative, intPartLength);",
            "}",
            "int c = (int) _inputBuffer[_inputPtr++] & 0xFF;",
            "if (c > INT_9 || c < INT_0) {",
            "if (c == INT_PERIOD || c == INT_e || c == INT_E) {",
            "return _parseFloat(outBuf, outPtr, c, negative, intPartLength);",
            "}",
            "break;",
            "}",
            "if (outPtr >= outBuf.length) {",
            "outBuf = _textBuffer.finishCurrentSegment();",
            "outPtr = 0;",
            "}",
            "outBuf[outPtr++] = (char) c;",
            "++intPartLength;",
            "}",
            "--_inputPtr; // to push back trailing char (comma etc)",
            "_textBuffer.setCurrentLength(outPtr);",
            "// As per #105, need separating space between root values; check here",
            "if (_parsingContext.inRoot()) {",
            "_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);",
            "}",
            "",
            "// And there we have it!",
            "return resetInt(negative, intPartLength);",
            "",
            "}"
        ],
        "new_line": "if (c > INT_9 != c < INT_0) {",
        "tst_lines": [
            "public void testNextLongValue() throws Exception",
            "{",
            "_textNextLong(MODE_INPUT_STREAM);",
            "_textNextLong(MODE_INPUT_STREAM_THROTTLED);",
            "_textNextLong(MODE_DATA_INPUT);",
            "_textNextLong(MODE_READER);",
            "}"
        ],
        "before_pmt": "c, >, INT_9, ||, c, <, INT_0,",
        "after_pmt": "c, >, INT_9, !=, c, <, INT_0,",
        "mutator": "COR",
        "mut_src_line_no": 10,
        "label": 0
    },
    {
        "mut_no": 6689,
        "test_method": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest.testIndexMatchWithPath2",
        "source_method": "checkValue(com.fasterxml.jackson.core.filter.TokenFilter)",
        "src_lines": [
            "public TokenFilter checkValue(TokenFilter filter) {",
            "// First, checks for Object properties have been made earlier:",
            "if (_type == TYPE_OBJECT) {",
            "return filter;",
            "}",
            "// We increase it first because at the beginning of array, value is -1",
            "int ix = ++_index;",
            "if (_type == TYPE_ARRAY) {",
            "return filter.includeElement(ix);",
            "}",
            "return filter.includeRootValue(ix);",
            "}"
        ],
        "new_line": "if (_type <= TYPE_OBJECT) {",
        "tst_lines": [
            "public void testIndexMatchWithPath2() throws Exception",
            "{",
            "FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),",
            "new IndexMatchFilter(0, 1), true, true);",
            "assertEquals(aposToQuotes(\"{'array':[1,2]}\"), readAndWrite(JSON_F, p));",
            "assertEquals(2, p.getMatchCount());",
            "",
            "String JSON = aposToQuotes(\"{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}\");",
            "p = new FilteringParserDelegate(JSON_F.createParser(JSON),",
            "new IndexMatchFilter(1, 3), true, true);",
            "assertEquals(aposToQuotes(\"{'array':[2,4],'b':[2]}\"), readAndWrite(JSON_F, p));",
            "assertEquals(3, p.getMatchCount());",
            "}"
        ],
        "before_pmt": "_type, ==, TYPE_OBJECT,",
        "after_pmt": "_type, <=, TYPE_OBJECT,",
        "mutator": "ROR",
        "mut_src_line_no": 2,
        "label": 1
    },
    {
        "mut_no": 34456,
        "test_method": "org.jfree.chart.axis.junit.SegmentedTimelineTests.testMondayThoughFridayExceptionSegments",
        "source_method": "calculateSegmentNumber(long)",
        "src_lines": [
            "public long calculateSegmentNumber(long millis) {",
            "if (millis >= SegmentedTimeline.this.startTime) {",
            "return (millis - SegmentedTimeline.this.startTime)",
            "/ SegmentedTimeline.this.segmentSize;",
            "}",
            "else {",
            "return ((millis - SegmentedTimeline.this.startTime)",
            "/ SegmentedTimeline.this.segmentSize) - 1;",
            "}",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testMondayThoughFridayExceptionSegments()",
            "throws ParseException {",
            "verifyExceptionSegments(this.mondayFridayTimeline,",
            "US_HOLIDAYS, DATE_FORMAT);",
            "}"
        ],
        "before_pmt": "millis, >=, SegmentedTimeline, ., this, ., startTime,",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 72,
        "test_method": "com.google.gson.functional.FieldNamingTest.testUpperCamelCaseWithSpaces",
        "source_method": "open(int,java.lang.String)",
        "src_lines": [
            "private JsonWriter open(int empty, String openBracket) throws IOException {",
            "beforeValue();",
            "push(empty);",
            "out.write(openBracket);",
            "return this;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testUpperCamelCaseWithSpaces() {",
            "Gson gson = getGsonWithNamingPolicy(UPPER_CAMEL_CASE_WITH_SPACES);",
            "assertEquals(\"{'Lower Camel':1,'Upper Camel':2,'_Lower Camel Leading Underscore':3,\" +",
            "\"'_ Upper Camel Leading Underscore':4,'Lower_words':5,'U P P E R_ W O R D S':6,\" +",
            "\"'annotatedName':7,'Lower Id':8}\",",
            "gson.toJson(new TestNames()).replace('\\\"', '\\''));",
            "}"
        ],
        "before_pmt": "beforeValue, (, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 65481,
        "test_method": "org.jfree.chart.renderer.category.junit.LevelRendererTests.testEquals",
        "source_method": "equal(java.awt.Paint,java.awt.Paint)",
        "src_lines": [
            "public static boolean equal(Paint p1, Paint p2) {",
            "",
            "// handle cases where either or both arguments are null",
            "if (p1 == null) {",
            "return (p2 == null);",
            "}",
            "if (p2 == null) {",
            "return false;",
            "}",
            "",
            "boolean result = false;",
            "// handle GradientPaint as a special case...",
            "if (p1 instanceof GradientPaint && p2 instanceof GradientPaint) {",
            "GradientPaint gp1 = (GradientPaint) p1;",
            "GradientPaint gp2 = (GradientPaint) p2;",
            "result = gp1.getColor1().equals(gp2.getColor1())",
            "&& gp1.getColor2().equals(gp2.getColor2())",
            "&& gp1.getPoint1().equals(gp2.getPoint1())",
            "&& gp1.getPoint2().equals(gp2.getPoint2())",
            "&& gp1.isCyclic() == gp2.isCyclic()",
            "&& gp1.getTransparency() == gp1.getTransparency();",
            "}",
            "else {",
            "result = p1.equals(p2);",
            "}",
            "return result;",
            "",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testEquals() {",
            "LevelRenderer r1 = new LevelRenderer();",
            "LevelRenderer r2 = new LevelRenderer();",
            "assertTrue(r1.equals(r2));",
            "assertTrue(r2.equals(r1));",
            "",
            "r1.setItemMargin(0.123);",
            "assertFalse(r1.equals(r2));",
            "r2.setItemMargin(0.123);",
            "assertTrue(r1.equals(r2));",
            "",
            "r1.setMaximumItemWidth(0.234);",
            "assertFalse(r1.equals(r2));",
            "r2.setMaximumItemWidth(0.234);",
            "assertTrue(r1.equals(r2));",
            "",
            "}"
        ],
        "before_pmt": "p1, ==, null,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 1
    },
    {
        "mut_no": 2869,
        "test_method": "com.google.gson.functional.EnumTest.testTopLevelEnumSerialization",
        "source_method": "create(com.google.gson.Gson,com.google.gson.reflect.TypeToken<T>)",
        "src_lines": [
            "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {",
            "Class<? super T> rawType = targetType.getRawType();",
            "JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);",
            "if (annotation == null) {",
            "return null;",
            "}",
            "return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testTopLevelEnumSerialization() throws Exception {",
            "String result = gson.toJson(MyEnum.VALUE1);",
            "assertEquals('\"' + MyEnum.VALUE1.toString() + '\"', result);",
            "}"
        ],
        "before_pmt": "annotation, ==, null,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 1
    },
    {
        "mut_no": 3018,
        "test_method": "com.fasterxml.jackson.core.json.async.AsyncStringArrayTest.testShortUnicodeStrings",
        "source_method": "_calcTertiaryShift(int)",
        "src_lines": [
            "static int _calcTertiaryShift(int primarySlots)",
            "{",
            "// first: we only get 1/4 of slots of primary, to divide",
            "int tertSlots = (primarySlots) >> 2;",
            "",
            "// default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)",
            "if (tertSlots < 64) {",
            "return 4;",
            "}",
            "if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)",
            "return 5;",
            "}",
            "if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)",
            "return 6;",
            "}",
            "// and biggest buckets have 32 slots",
            "return 7;",
            "}"
        ],
        "new_line": "return 0;",
        "tst_lines": [
            "public void testShortUnicodeStrings() throws IOException",
            "{",
            "final String repeat = \"Test: \"+UNICODE_2BYTES;",
            "final String[] input = new String[] {",
            "repeat, \"\",",
            "\"\"+UNICODE_3BYTES,",
            "\"\"+UNICODE_2BYTES,",
            "// 60 chars, to stay short",
            "String.format(\"%s %c %s %c %s\",",
            "str0to9, UNICODE_3BYTES,",
            "str0to9, UNICODE_2BYTES, str0to9),",
            "\"Test\", repeat,",
            "\"!\"",
            "};",
            "JsonFactory f = JSON_F;",
            "byte[] data = _stringDoc(f, input);",
            "",
            "// first: require headers, no offsets",
            "_testStrings(f, input, data, 0, 100);",
            "_testStrings(f, input, data, 0, 3);",
            "_testStrings(f, input, data, 0, 1);",
            "",
            "// then with some offsets:",
            "_testStrings(f, input, data, 1, 100);",
            "_testStrings(f, input, data, 1, 3);",
            "_testStrings(f, input, data, 1, 1);",
            "}"
        ],
        "before_pmt": "4,",
        "after_pmt": "0,",
        "mutator": "LVR",
        "mut_src_line_no": 7,
        "label": 0
    },
    {
        "mut_no": 24281,
        "test_method": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest.testIndexMatchWithPath2",
        "source_method": "_writeString(java.lang.String)",
        "src_lines": [
            "private void _writeString(String text) throws IOException",
            "{",
            "/* One check first: if String won't fit in the buffer, let's",
            "* segment writes. No point in extending buffer to huge sizes",
            "* (like if someone wants to include multi-megabyte base64",
            "* encoded stuff or such)",
            "*/",
            "final int len = text.length();",
            "if (len > _outputEnd) { // Let's reserve space for entity at begin/end",
            "_writeLongString(text);",
            "return;",
            "}",
            "",
            "// Ok: we know String will fit in buffer ok",
            "// But do we need to flush first?",
            "if ((_outputTail + len) > _outputEnd) {",
            "_flushBuffer();",
            "}",
            "text.getChars(0, len, _outputBuffer, _outputTail);",
            "",
            "if (_characterEscapes != null) {",
            "_writeStringCustom(len);",
            "} else if (_maximumNonEscapedChar != 0) {",
            "_writeStringASCII(len, _maximumNonEscapedChar);",
            "} else {",
            "_writeString2(len);",
            "}",
            "}"
        ],
        "new_line": "if ((_outputTail % len) > _outputEnd) {",
        "tst_lines": [
            "public void testIndexMatchWithPath2() throws Exception",
            "{",
            "FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),",
            "new IndexMatchFilter(0, 1), true, true);",
            "assertEquals(aposToQuotes(\"{'array':[1,2]}\"), readAndWrite(JSON_F, p));",
            "assertEquals(2, p.getMatchCount());",
            "",
            "String JSON = aposToQuotes(\"{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}\");",
            "p = new FilteringParserDelegate(JSON_F.createParser(JSON),",
            "new IndexMatchFilter(1, 3), true, true);",
            "assertEquals(aposToQuotes(\"{'array':[2,4],'b':[2]}\"), readAndWrite(JSON_F, p));",
            "assertEquals(3, p.getMatchCount());",
            "}"
        ],
        "before_pmt": "_outputTail, +, len,",
        "after_pmt": "_outputTail, %, len,",
        "mutator": "AOR",
        "mut_src_line_no": 15,
        "label": 0
    },
    {
        "mut_no": 70746,
        "test_method": "org.jfree.data.xy.junit.XYSeriesTests.testGetMinX",
        "source_method": "compareTo(java.lang.Object)",
        "src_lines": [
            "public int compareTo(Object o1) {",
            "",
            "int result;",
            "",
            "// CASE 1 : Comparing to another TimeSeriesDataPair object",
            "// -------------------------------------------------------",
            "if (o1 instanceof XYDataItem) {",
            "XYDataItem dataItem = (XYDataItem) o1;",
            "double compare = this.x.doubleValue()",
            "- dataItem.getX().doubleValue();",
            "if (compare > 0.0) {",
            "result = 1;",
            "}",
            "else {",
            "if (compare < 0.0) {",
            "result = -1;",
            "}",
            "else {",
            "result = 0;",
            "}",
            "}",
            "}",
            "",
            "// CASE 2 : Comparing to a general object",
            "// ---------------------------------------------",
            "else {",
            "// consider time periods to be ordered after general objects",
            "result = 1;",
            "}",
            "",
            "return result;",
            "",
            "}"
        ],
        "new_line": "result = 1;",
        "tst_lines": [
            "public void testGetMinX() {",
            "XYSeries s1 = new XYSeries(\"S1\");",
            "assertTrue(Double.isNaN(s1.getMinX()));",
            "",
            "s1.add(1.0, 1.1);",
            "assertEquals(1.0, s1.getMinX(), EPSILON);",
            "",
            "s1.add(2.0, 2.2);",
            "assertEquals(1.0, s1.getMinX(), EPSILON);",
            "",
            "s1.add(Double.NaN, 99.9);",
            "assertEquals(1.0, s1.getMinX(), EPSILON);",
            "",
            "s1.add(-1.0, -1.1);",
            "assertEquals(-1.0, s1.getMinX(), EPSILON);",
            "",
            "s1.add(0.0, null);",
            "assertEquals(-1.0, s1.getMinX(), EPSILON);",
            "}"
        ],
        "before_pmt": "-, 1,",
        "after_pmt": "1,",
        "mutator": "LVR",
        "mut_src_line_no": 15,
        "label": 0
    },
    {
        "mut_no": 866,
        "test_method": "com.google.gson.functional.CollectionTest.testRawCollectionOfBagOfPrimitivesNotAllowed",
        "source_method": "nextString()",
        "src_lines": [
            "public String nextString() throws IOException {",
            "int p = peeked;",
            "if (p == PEEKED_NONE) {",
            "p = doPeek();",
            "}",
            "String result;",
            "if (p == PEEKED_UNQUOTED) {",
            "result = nextUnquotedValue();",
            "} else if (p == PEEKED_SINGLE_QUOTED) {",
            "result = nextQuotedValue('\\'');",
            "} else if (p == PEEKED_DOUBLE_QUOTED) {",
            "result = nextQuotedValue('\"');",
            "} else if (p == PEEKED_BUFFERED) {",
            "result = peekedString;",
            "peekedString = null;",
            "} else if (p == PEEKED_LONG) {",
            "result = Long.toString(peekedLong);",
            "} else if (p == PEEKED_NUMBER) {",
            "result = new String(buffer, pos, peekedNumberLength);",
            "pos += peekedNumberLength;",
            "} else {",
            "throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());",
            "}",
            "peeked = PEEKED_NONE;",
            "pathIndices[stackSize - 1]++;",
            "return result;",
            "}"
        ],
        "new_line": "if (p >= PEEKED_UNQUOTED) {",
        "tst_lines": [
            "public void testRawCollectionOfBagOfPrimitivesNotAllowed() {",
            "BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, \"stringValue\");",
            "String json = '[' + bag.getExpectedJson() + ',' + bag.getExpectedJson() + ']';",
            "Collection target = gson.fromJson(json, Collection.class);",
            "assertEquals(2, target.size());",
            "for (Object bag1 : target) {",
            "// Gson 2.0 converts raw objects into maps",
            "Map<String, Object> values = (Map<String, Object>) bag1;",
            "assertTrue(values.containsValue(10.0));",
            "assertTrue(values.containsValue(20.0));",
            "assertTrue(values.containsValue(\"stringValue\"));",
            "}",
            "}"
        ],
        "before_pmt": "p, ==, PEEKED_UNQUOTED,",
        "after_pmt": "p, >=, PEEKED_UNQUOTED,",
        "mutator": "ROR",
        "mut_src_line_no": 6,
        "label": 0
    },
    {
        "mut_no": 8796,
        "test_method": "org.apache.commons.lang3.text.StrTokenizerTest.testBasicEmpty1",
        "source_method": "append(char)",
        "src_lines": [
            "public StrBuilder append(final char ch) {",
            "final int len = length();",
            "ensureCapacity(len + 1);",
            "buffer[size++] = ch;",
            "return this;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testBasicEmpty1() {",
            "final String input = \"a  b c\";",
            "final StrTokenizer tok = new StrTokenizer(input);",
            "tok.setIgnoreEmptyTokens(false);",
            "assertEquals(\"a\", tok.next());",
            "assertEquals(\"\", tok.next());",
            "assertEquals(\"b\", tok.next());",
            "assertEquals(\"c\", tok.next());",
            "assertFalse(tok.hasNext());",
            "}"
        ],
        "before_pmt": "buffer, [, size, ++, ], =, ch,",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 3,
        "label": 1
    },
    {
        "mut_no": 3227,
        "test_method": "com.fasterxml.jackson.core.read.NonStandardUnquotedNamesTest.testSimpleUnquotedBytes",
        "source_method": "collectDefaults()",
        "src_lines": [
            "public static int collectDefaults()",
            "{",
            "int flags = 0;",
            "for (Feature f : values()) {",
            "if (f.enabledByDefault()) {",
            "flags |= f.getMask();",
            "}",
            "}",
            "return flags;",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testSimpleUnquotedBytes() throws Exception {",
            "_testSimpleUnquoted(MODE_INPUT_STREAM);",
            "_testSimpleUnquoted(MODE_INPUT_STREAM_THROTTLED);",
            "_testSimpleUnquoted(MODE_DATA_INPUT);",
            "}"
        ],
        "before_pmt": "f, ., enabledByDefault, (, ),",
        "after_pmt": "true,",
        "mutator": "COR",
        "mut_src_line_no": 4,
        "label": 1
    },
    {
        "mut_no": 10816,
        "test_method": "org.jfree.chart.renderer.xy.junit.StackedXYAreaRenderer2Tests.testDrawWithEmptyDataset",
        "source_method": "equals(java.lang.Object)",
        "src_lines": [
            "public boolean equals(Object obj) {",
            "",
            "if (this == obj) {",
            "return true;",
            "}",
            "if (!(obj instanceof Layer)) {",
            "return false;",
            "}",
            "",
            "Layer layer = (Layer) obj;",
            "if (!this.name.equals(layer.name)) {",
            "return false;",
            "}",
            "",
            "return true;",
            "",
            "}"
        ],
        "new_line": "if (!false) {",
        "tst_lines": [
            "public void testDrawWithEmptyDataset() {",
            "boolean success = false;",
            "JFreeChart chart = ChartFactory.createStackedXYAreaChart(\"title\", \"x\",",
            "\"y\", new DefaultTableXYDataset(), true);",
            "XYPlot plot = (XYPlot) chart.getPlot();",
            "plot.setRenderer(new StackedXYAreaRenderer2());",
            "try {",
            "BufferedImage image = new BufferedImage(200 , 100,",
            "BufferedImage.TYPE_INT_RGB);",
            "Graphics2D g2 = image.createGraphics();",
            "chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);",
            "g2.dispose();",
            "success = true;",
            "}",
            "catch (Exception e) {",
            "success = false;",
            "}",
            "assertTrue(success);",
            "}"
        ],
        "before_pmt": "this, ., name, ., equals, (, layer, ., name, ),",
        "after_pmt": "false,",
        "mutator": "COR",
        "mut_src_line_no": 10,
        "label": 0
    },
    {
        "mut_no": 77593,
        "test_method": "org.jfree.data.time.junit.TimeSeriesCollectionTests.testSerialization",
        "source_method": "<init>(int,int,int)",
        "src_lines": [
            "public SpreadsheetDate(final int day, final int month, final int year) {",
            "",
            "if ((year >= 1900) && (year <= 9999)) {",
            "this.year = year;",
            "}",
            "else {",
            "throw new IllegalArgumentException(",
            "\"The 'year' argument must be in range 1900 to 9999.\"",
            ");",
            "}",
            "",
            "if ((month >= MonthConstants.JANUARY)",
            "&& (month <= MonthConstants.DECEMBER)) {",
            "this.month = month;",
            "}",
            "else {",
            "throw new IllegalArgumentException(",
            "\"The 'month' argument must be in the range 1 to 12.\"",
            ");",
            "}",
            "",
            "if ((day >= 1) && (day <= SerialDate.lastDayOfMonth(month, year))) {",
            "this.day = day;",
            "}",
            "else {",
            "throw new IllegalArgumentException(\"Invalid 'day' argument.\");",
            "}",
            "",
            "// the serial number needs to be synchronised with the day-month-year...",
            "this.serial = calcSerial(day, month, year);",
            "",
            "}"
        ],
        "new_line": "if ((day >= 1) && (day == SerialDate.lastDayOfMonth(month, year))) {",
        "tst_lines": [
            "public void testSerialization() {",
            "TimeSeriesCollection c1 = new TimeSeriesCollection(createSeries());",
            "TimeSeriesCollection c2 = null;",
            "try {",
            "ByteArrayOutputStream buffer = new ByteArrayOutputStream();",
            "ObjectOutput out = new ObjectOutputStream(buffer);",
            "out.writeObject(c1);",
            "out.close();",
            "",
            "ObjectInput in = new ObjectInputStream(",
            "new ByteArrayInputStream(buffer.toByteArray()));",
            "c2 = (TimeSeriesCollection) in.readObject();",
            "in.close();",
            "}",
            "catch (Exception e) {",
            "e.printStackTrace();",
            "}",
            "assertEquals(c1, c2);",
            "}"
        ],
        "before_pmt": "day, <=, SerialDate, ., lastDayOfMonth, (, month, ,, year, ),",
        "after_pmt": "day, ==, SerialDate, ., lastDayOfMonth, (, month, ,, year, ),",
        "mutator": "ROR",
        "mut_src_line_no": 21,
        "label": 1
    },
    {
        "mut_no": 108,
        "test_method": "com.google.gson.functional.NullObjectAndFieldTest.testExplicitSerializationOfNullStringMembers",
        "source_method": "peek()",
        "src_lines": [
            "private int peek() {",
            "if (stackSize == 0) {",
            "throw new IllegalStateException(\"JsonWriter is closed.\");",
            "}",
            "return stack[stackSize - 1];",
            "}"
        ],
        "new_line": "if (stackSize == 1) {",
        "tst_lines": [
            "public void testExplicitSerializationOfNullStringMembers() {",
            "Gson gson = gsonBuilder.create();",
            "ClassWithMembers target = new ClassWithMembers();",
            "String json = gson.toJson(target);",
            "assertTrue(json.contains(\"\\\"str\\\":null\"));",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "1,",
        "mutator": "LVR",
        "mut_src_line_no": 1,
        "label": 1
    },
    {
        "mut_no": 2774,
        "test_method": "com.google.gson.functional.JsonParserTest.testBadFieldTypeForCustomDeserializerCustomTree",
        "source_method": "excludeField(java.lang.reflect.Field,boolean)",
        "src_lines": [
            "public boolean excludeField(Field field, boolean serialize) {",
            "if ((modifiers & field.getModifiers()) != 0) {",
            "return true;",
            "}",
            "",
            "if (version != Excluder.IGNORE_VERSIONS",
            "&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {",
            "return true;",
            "}",
            "",
            "if (field.isSynthetic()) {",
            "return true;",
            "}",
            "",
            "if (requireExpose) {",
            "Expose annotation = field.getAnnotation(Expose.class);",
            "if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {",
            "return true;",
            "}",
            "}",
            "",
            "if (!serializeInnerClasses && isInnerClass(field.getType())) {",
            "return true;",
            "}",
            "",
            "if (isAnonymousOrLocal(field.getType())) {",
            "return true;",
            "}",
            "",
            "List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;",
            "if (!list.isEmpty()) {",
            "FieldAttributes fieldAttributes = new FieldAttributes(field);",
            "for (ExclusionStrategy exclusionStrategy : list) {",
            "if (exclusionStrategy.shouldSkipField(fieldAttributes)) {",
            "return true;",
            "}",
            "}",
            "}",
            "",
            "return false;",
            "}"
        ],
        "new_line": "return false;",
        "tst_lines": [
            "public void testBadFieldTypeForCustomDeserializerCustomTree() {",
            "JsonArray array = new JsonArray();",
            "array.add(new JsonPrimitive(\"blah\"));",
            "JsonObject obj = new JsonObject();",
            "obj.addProperty(\"stringValue\", \"foo\");",
            "obj.addProperty(\"intValue\", 11);",
            "obj.add(\"longValue\", array);",
            "",
            "try {",
            "gson.fromJson(obj, BagOfPrimitives.class);",
            "fail(\"BagOfPrimitives is not an array\");",
            "} catch (JsonParseException expected) { }",
            "}"
        ],
        "before_pmt": "true,",
        "after_pmt": "false,",
        "mutator": "LVR",
        "mut_src_line_no": 2,
        "label": 0
    },
    {
        "mut_no": 1471,
        "test_method": "com.google.gson.functional.ObjectTest.testClassWithNoFieldsDeserialization",
        "source_method": "fillBuffer(int)",
        "src_lines": [
            "private boolean fillBuffer(int minimum) throws IOException {",
            "char[] buffer = this.buffer;",
            "lineStart -= pos;",
            "if (limit != pos) {",
            "limit -= pos;",
            "System.arraycopy(buffer, pos, buffer, 0, limit);",
            "} else {",
            "limit = 0;",
            "}",
            "",
            "pos = 0;",
            "int total;",
            "while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {",
            "limit += total;",
            "",
            "// if this is the first read, consume an optional byte order mark (BOM) if it exists",
            "if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {",
            "pos++;",
            "lineStart++;",
            "minimum++;",
            "}",
            "",
            "if (limit >= minimum) {",
            "return true;",
            "}",
            "}",
            "return false;",
            "}"
        ],
        "new_line": "if (lineNumber == -1 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {",
        "tst_lines": [
            "public void testClassWithNoFieldsDeserialization() throws Exception {",
            "String json = \"{}\";",
            "ClassWithNoFields target = gson.fromJson(json, ClassWithNoFields.class);",
            "ClassWithNoFields expected = new ClassWithNoFields();",
            "assertEquals(expected, target);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 16,
        "label": 1
    },
    {
        "mut_no": 1860,
        "test_method": "org.jfree.chart.title.junit.DateTitleTests.testEquals",
        "source_method": "setFont(java.awt.Font)",
        "src_lines": [
            "public void setFont(Font font) {",
            "if (font == null) {",
            "throw new IllegalArgumentException(\"Null 'font' argument.\");",
            "}",
            "if (!this.font.equals(font)) {",
            "this.font = font;",
            "notifyListeners(new TitleChangeEvent(this));",
            "}",
            "}"
        ],
        "new_line": "if (!false) {",
        "tst_lines": [
            "public void testEquals() {",
            "DateTitle t1 = new DateTitle();",
            "DateTitle t2 = new DateTitle();",
            "assertEquals(t1, t2);",
            "",
            "t1.setText(\"Test 1\");",
            "assertFalse(t1.equals(t2));",
            "t2.setText(\"Test 1\");",
            "assertTrue(t1.equals(t2));",
            "",
            "Font f = new Font(\"SansSerif\", Font.PLAIN, 15);",
            "t1.setFont(f);",
            "assertFalse(t1.equals(t2));",
            "t2.setFont(f);",
            "assertTrue(t1.equals(t2));",
            "",
            "t1.setPaint(Color.blue);",
            "assertFalse(t1.equals(t2));",
            "t2.setPaint(Color.blue);",
            "assertTrue(t1.equals(t2));",
            "",
            "t1.setBackgroundPaint(Color.blue);",
            "assertFalse(t1.equals(t2));",
            "t2.setBackgroundPaint(Color.blue);",
            "assertTrue(t1.equals(t2));",
            "",
            "}"
        ],
        "before_pmt": "this, ., font, ., equals, (, font, ),",
        "after_pmt": "false,",
        "mutator": "COR",
        "mut_src_line_no": 4,
        "label": 0
    },
    {
        "mut_no": 3765,
        "test_method": "com.google.gson.JavaSerializationTest.testMapIsSerializable",
        "source_method": "create(com.google.gson.Gson,com.google.gson.reflect.TypeToken<T>)",
        "src_lines": [
            "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {",
            "Type type = typeToken.getType();",
            "",
            "Class<? super T> rawType = typeToken.getRawType();",
            "if (!Collection.class.isAssignableFrom(rawType)) {",
            "return null;",
            "}",
            "",
            "Type elementType = $Gson$Types.getCollectionElementType(type, rawType);",
            "TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));",
            "ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);",
            "",
            "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter",
            "TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);",
            "return result;",
            "}"
        ],
        "new_line": "if (!true) {",
        "tst_lines": [
            "public void testMapIsSerializable() throws Exception {",
            "Type type = new TypeToken<Map<String, Integer>>() {}.getType();",
            "Map<String, Integer> map = gson.fromJson(\"{\\\"b\\\":1,\\\"c\\\":2,\\\"a\\\":3}\", type);",
            "Map<String, Integer> serialized = serializedCopy(map);",
            "assertEquals(map, serialized);",
            "// Also check that the iteration order is retained.",
            "assertEquals(Arrays.asList(\"b\", \"c\", \"a\"), new ArrayList<String>(serialized.keySet()));",
            "}"
        ],
        "before_pmt": "Collection, ., class, ., isAssignableFrom, (, rawType, ),",
        "after_pmt": "true,",
        "mutator": "COR",
        "mut_src_line_no": 4,
        "label": 1
    },
    {
        "mut_no": 333,
        "test_method": "com.google.gson.stream.JsonReaderTest.testUnterminatedStringFailure",
        "source_method": "beginArray()",
        "src_lines": [
            "public void beginArray() throws IOException {",
            "int p = peeked;",
            "if (p == PEEKED_NONE) {",
            "p = doPeek();",
            "}",
            "if (p == PEEKED_BEGIN_ARRAY) {",
            "push(JsonScope.EMPTY_ARRAY);",
            "pathIndices[stackSize - 1] = 0;",
            "peeked = PEEKED_NONE;",
            "} else {",
            "throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());",
            "}",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testUnterminatedStringFailure() throws IOException {",
            "JsonReader reader = new JsonReader(reader(\"[\\\"string\"));",
            "reader.setLenient(true);",
            "reader.beginArray();",
            "assertEquals(JsonToken.STRING, reader.peek());",
            "try {",
            "reader.nextString();",
            "fail();",
            "} catch (MalformedJsonException expected) {",
            "}",
            "}"
        ],
        "before_pmt": "push, (, JsonScope, ., EMPTY_ARRAY, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 6,
        "label": 0
    },
    {
        "mut_no": 4307,
        "test_method": "com.google.gson.functional.DefaultTypeAdaptersTest.testBigDecimalFieldDeserialization",
        "source_method": "getBoundFields(com.google.gson.Gson,com.google.gson.reflect.TypeToken<?>,java.lang.Class<?>)",
        "src_lines": [
            "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {",
            "Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();",
            "if (raw.isInterface()) {",
            "return result;",
            "}",
            "",
            "Type declaredType = type.getType();",
            "while (raw != Object.class) {",
            "Field[] fields = raw.getDeclaredFields();",
            "for (Field field : fields) {",
            "boolean serialize = excludeField(field, true);",
            "boolean deserialize = excludeField(field, false);",
            "if (!serialize && !deserialize) {",
            "continue;",
            "}",
            "field.setAccessible(true);",
            "Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());",
            "List<String> fieldNames = getFieldNames(field);",
            "BoundField previous = null;",
            "for (int i = 0, size = fieldNames.size(); i < size; ++i) {",
            "String name = fieldNames.get(i);",
            "if (i != 0) serialize = false; // only serialize the default name",
            "BoundField boundField = createBoundField(context, field, name,",
            "TypeToken.get(fieldType), serialize, deserialize);",
            "BoundField replaced = result.put(name, boundField);",
            "if (previous == null) previous = replaced;",
            "}",
            "if (previous != null) {",
            "throw new IllegalArgumentException(declaredType",
            "+ \" declares multiple JSON fields named \" + previous.name);",
            "}",
            "}",
            "type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));",
            "raw = type.getRawType();",
            "}",
            "return result;",
            "}"
        ],
        "new_line": "if (i != 1) serialize = false; // only serialize the default name",
        "tst_lines": [
            "public void testBigDecimalFieldDeserialization() {",
            "ClassWithBigDecimal expected = new ClassWithBigDecimal(\"-122.01e-21\");",
            "String json = expected.getExpectedJson();",
            "ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class);",
            "assertEquals(expected.value, actual.value);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "1,",
        "mutator": "LVR",
        "mut_src_line_no": 21,
        "label": 0
    },
    {
        "mut_no": 20189,
        "test_method": "com.fasterxml.jackson.core.read.NextXxxAccessTest.testNextTextValue",
        "source_method": "_parseNumber2(char[],int,boolean,int)",
        "src_lines": [
            "private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,",
            "int intPartLength) throws IOException",
            "{",
            "// Ok, parse the rest",
            "while (true) {",
            "if (_inputPtr >= _inputEnd && !_loadMore()) {",
            "_textBuffer.setCurrentLength(outPtr);",
            "return resetInt(negative, intPartLength);",
            "}",
            "int c = (int) _inputBuffer[_inputPtr++] & 0xFF;",
            "if (c > INT_9 || c < INT_0) {",
            "if (c == INT_PERIOD || c == INT_e || c == INT_E) {",
            "return _parseFloat(outBuf, outPtr, c, negative, intPartLength);",
            "}",
            "break;",
            "}",
            "if (outPtr >= outBuf.length) {",
            "outBuf = _textBuffer.finishCurrentSegment();",
            "outPtr = 0;",
            "}",
            "outBuf[outPtr++] = (char) c;",
            "++intPartLength;",
            "}",
            "--_inputPtr; // to push back trailing char (comma etc)",
            "_textBuffer.setCurrentLength(outPtr);",
            "// As per #105, need separating space between root values; check here",
            "if (_parsingContext.inRoot()) {",
            "_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);",
            "}",
            "",
            "// And there we have it!",
            "return resetInt(negative, intPartLength);",
            "",
            "}"
        ],
        "new_line": "if (false || c < INT_0) {",
        "tst_lines": [
            "public void testNextTextValue() throws Exception",
            "{",
            "_textNextText(MODE_INPUT_STREAM);",
            "_textNextText(MODE_INPUT_STREAM_THROTTLED);",
            "_textNextText(MODE_DATA_INPUT);",
            "_textNextText(MODE_READER);",
            "}"
        ],
        "before_pmt": "c, >, INT_9,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 10,
        "label": 0
    },
    {
        "mut_no": 11028,
        "test_method": "com.fasterxml.jackson.core.base64.Base64BinaryParsingTest.testWithEscaped",
        "source_method": "ensureLoaded(int)",
        "src_lines": [
            "protected boolean ensureLoaded(int minimum) throws IOException {",
            "/* Let's assume here buffer has enough room -- this will always",
            "* be true for the limited used this method gets",
            "*/",
            "int gotten = (_inputEnd - _inputPtr);",
            "while (gotten < minimum) {",
            "int count;",
            "",
            "if (_in == null) { // block source",
            "count = -1;",
            "} else {",
            "count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);",
            "}",
            "if (count < 1) {",
            "return false;",
            "}",
            "_inputEnd += count;",
            "gotten += count;",
            "}",
            "return true;",
            "}"
        ],
        "new_line": "while (false) {",
        "tst_lines": [
            "public void testWithEscaped() throws IOException {",
            "for (int mode : ALL_MODES) {",
            "_testEscaped(mode);",
            "}",
            "}"
        ],
        "before_pmt": "gotten, <, minimum,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 5,
        "label": 1
    },
    {
        "mut_no": 4339,
        "test_method": "com.fasterxml.jackson.core.util.TestTextBuffer.testAppendTakingTwoAndThreeInts",
        "source_method": "append(java.lang.String,int,int)",
        "src_lines": [
            "public void append(String str, int offset, int len)",
            "{",
            "// Can't append to shared buf (sanity check)",
            "if (_inputStart >= 0) {",
            "unshare(len);",
            "}",
            "_resultString = null;",
            "_resultArray = null;",
            "",
            "// Room in current segment?",
            "char[] curr = _currentSegment;",
            "int max = curr.length - _currentSize;",
            "if (max >= len) {",
            "str.getChars(offset, offset+len, curr, _currentSize);",
            "_currentSize += len;",
            "return;",
            "}",
            "// No room for all, need to copy part(s):",
            "if (max > 0) {",
            "str.getChars(offset, offset+max, curr, _currentSize);",
            "len -= max;",
            "offset += max;",
            "}",
            "// And then allocate new segment; we are guaranteed to now",
            "// have enough room in segment.",
            "do {",
            "expand(len);",
            "int amount = Math.min(_currentSegment.length, len);",
            "str.getChars(offset, offset+amount, _currentSegment, 0);",
            "_currentSize += amount;",
            "offset += amount;",
            "len -= amount;",
            "} while (len > 0);",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testAppendTakingTwoAndThreeInts() {",
            "BufferRecycler bufferRecycler = new BufferRecycler();",
            "TextBuffer textBuffer = new TextBuffer(bufferRecycler);",
            "textBuffer.ensureNotShared();",
            "char[] charArray = textBuffer.getTextBuffer();",
            "textBuffer.append(charArray, 0, 200);",
            "textBuffer.append(\"5rmk0rx(C@aVYGN@Q\", 2, 3);",
            "",
            "assertEquals(3, textBuffer.getCurrentSegmentSize());",
            "}"
        ],
        "before_pmt": "str, ., getChars, (, offset, ,, offset, +, amount, ,, _currentSegment, ,, 0, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 28,
        "label": 0
    },
    {
        "mut_no": 72,
        "test_method": "com.google.gson.functional.ConcurrencyTest.testSingleThreadSerialization",
        "source_method": "open(int,java.lang.String)",
        "src_lines": [
            "private JsonWriter open(int empty, String openBracket) throws IOException {",
            "beforeValue();",
            "push(empty);",
            "out.write(openBracket);",
            "return this;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testSingleThreadSerialization() {",
            "MyObject myObj = new MyObject();",
            "for (int i = 0; i < 10; i++) {",
            "gson.toJson(myObj);",
            "}",
            "}"
        ],
        "before_pmt": "beforeValue, (, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 22485,
        "test_method": "com.fasterxml.jackson.core.read.CommentParsingTest.testCommentsDisabled",
        "source_method": "_skipWSOrEnd2()",
        "src_lines": [
            "private final int _skipWSOrEnd2() throws IOException",
            "{",
            "while ((_inputPtr < _inputEnd) || _loadMore()) {",
            "int i = _inputBuffer[_inputPtr++] & 0xFF;",
            "if (i > INT_SPACE) {",
            "if (i == INT_SLASH) {",
            "_skipComment();",
            "continue;",
            "}",
            "if (i == INT_HASH) {",
            "if (_skipYAMLComment()) {",
            "continue;",
            "}",
            "}",
            "return i;",
            "} else if (i != INT_SPACE) {",
            "if (i == INT_LF) {",
            "++_currInputRow;",
            "_currInputRowStart = _inputPtr;",
            "} else if (i == INT_CR) {",
            "_skipCR();",
            "} else if (i != INT_TAB) {",
            "_throwInvalidSpace(i);",
            "}",
            "}",
            "}",
            "// We ran out of input...",
            "return _eofAsNextChar();",
            "}"
        ],
        "new_line": "while (true) {",
        "tst_lines": [
            "public void testCommentsDisabled() throws Exception",
            "{",
            "_testDisabled(DOC_WITH_SLASHSTAR_COMMENT, MODE_INPUT_STREAM);",
            "_testDisabled(DOC_WITH_SLASHSLASH_COMMENT, MODE_INPUT_STREAM);",
            "_testDisabled(DOC_WITH_SLASHSTAR_COMMENT, MODE_INPUT_STREAM_THROTTLED);",
            "_testDisabled(DOC_WITH_SLASHSLASH_COMMENT, MODE_INPUT_STREAM_THROTTLED);",
            "_testDisabled(DOC_WITH_SLASHSTAR_COMMENT, MODE_READER);",
            "_testDisabled(DOC_WITH_SLASHSLASH_COMMENT, MODE_READER);",
            "_testDisabled(DOC_WITH_SLASHSTAR_COMMENT, MODE_DATA_INPUT);",
            "_testDisabled(DOC_WITH_SLASHSLASH_COMMENT, MODE_DATA_INPUT);",
            "}"
        ],
        "before_pmt": "(, _inputPtr, <, _inputEnd, ), ||, _loadMore, (, ),",
        "after_pmt": "true,",
        "mutator": "COR",
        "mut_src_line_no": 2,
        "label": 0
    },
    {
        "mut_no": 2631,
        "test_method": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.testClassAnnotationAdapterTakesPrecedenceOverDefault",
        "source_method": "fromJson(com.google.gson.stream.JsonReader,java.lang.reflect.Type)",
        "src_lines": [
            "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {",
            "boolean isEmpty = true;",
            "boolean oldLenient = reader.isLenient();",
            "reader.setLenient(true);",
            "try {",
            "reader.peek();",
            "isEmpty = false;",
            "TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);",
            "TypeAdapter<T> typeAdapter = getAdapter(typeToken);",
            "T object = typeAdapter.read(reader);",
            "return object;",
            "} catch (EOFException e) {",
            "/*",
            "* For compatibility with JSON 1.5 and earlier, we return null for empty",
            "* documents instead of throwing.",
            "*/",
            "if (isEmpty) {",
            "return null;",
            "}",
            "throw new JsonSyntaxException(e);",
            "} catch (IllegalStateException e) {",
            "throw new JsonSyntaxException(e);",
            "} catch (IOException e) {",
            "// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException",
            "throw new JsonSyntaxException(e);",
            "} finally {",
            "reader.setLenient(oldLenient);",
            "}",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testClassAnnotationAdapterTakesPrecedenceOverDefault() {",
            "Gson gson = new Gson();",
            "String json = gson.toJson(new Computer(new User(\"Inderjeet Singh\")));",
            "assertEquals(\"{\\\"user\\\":\\\"UserClassAnnotationAdapter\\\"}\", json);",
            "Computer computer = gson.fromJson(\"{'user':'Inderjeet Singh'}\", Computer.class);",
            "assertEquals(\"UserClassAnnotationAdapter\", computer.user.name);",
            "}"
        ],
        "before_pmt": "reader, ., setLenient, (, oldLenient, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 26,
        "label": 0
    },
    {
        "mut_no": 20591,
        "test_method": "com.fasterxml.jackson.core.read.JsonParserTest.testSpecExampleSkipping",
        "source_method": "parseMediumName(int)",
        "src_lines": [
            "protected final String parseMediumName(int q2) throws IOException",
            "{",
            "final byte[] input = _inputBuffer;",
            "final int[] codes = _icLatin1;",
            "",
            "// Ok, got 5 name bytes so far",
            "int i = input[_inputPtr++] & 0xFF;",
            "if (codes[i] != 0) {",
            "if (i == INT_QUOTE) { // 5 bytes",
            "return findName(_quad1, q2, 1);",
            "}",
            "return parseName(_quad1, q2, i, 1); // quoting or invalid char",
            "}",
            "q2 = (q2 << 8) | i;",
            "i = input[_inputPtr++] & 0xFF;",
            "if (codes[i] != 0) {",
            "if (i == INT_QUOTE) { // 6 bytes",
            "return findName(_quad1, q2, 2);",
            "}",
            "return parseName(_quad1, q2, i, 2);",
            "}",
            "q2 = (q2 << 8) | i;",
            "i = input[_inputPtr++] & 0xFF;",
            "if (codes[i] != 0) {",
            "if (i == INT_QUOTE) { // 7 bytes",
            "return findName(_quad1, q2, 3);",
            "}",
            "return parseName(_quad1, q2, i, 3);",
            "}",
            "q2 = (q2 << 8) | i;",
            "i = input[_inputPtr++] & 0xFF;",
            "if (codes[i] != 0) {",
            "if (i == INT_QUOTE) { // 8 bytes",
            "return findName(_quad1, q2, 4);",
            "}",
            "return parseName(_quad1, q2, i, 4);",
            "}",
            "return parseMediumName2(i, q2);",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testSpecExampleSkipping() throws Exception",
            "{",
            "_doTestSpec(false);",
            "}"
        ],
        "before_pmt": "i, =, input, [, _inputPtr, ++, ], &, 255,",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 14,
        "label": 0
    },
    {
        "mut_no": 8160,
        "test_method": "org.jfree.chart.renderer.category.junit.IntervalBarRendererTests.testCloning",
        "source_method": "clone()",
        "src_lines": [
            "public Object clone() throws CloneNotSupportedException {",
            "",
            "AbstractObjectList clone = (AbstractObjectList) super.clone();",
            "if (this.objects != null) {",
            "clone.objects = new Object[this.objects.length];",
            "System.arraycopy(this.objects, 0, clone.objects, 0,",
            "this.objects.length);",
            "}",
            "return clone;",
            "",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testCloning() {",
            "IntervalBarRenderer r1 = new IntervalBarRenderer();",
            "IntervalBarRenderer r2 = null;",
            "try {",
            "r2 = (IntervalBarRenderer) r1.clone();",
            "}",
            "catch (CloneNotSupportedException e) {",
            "System.err.println(\"Failed to clone.\");",
            "}",
            "assertTrue(r1 != r2);",
            "assertTrue(r1.getClass() == r2.getClass());",
            "assertTrue(r1.equals(r2));",
            "}"
        ],
        "before_pmt": "clone, ., objects, =, new, Object, [, this, ., objects, ., length, ],",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 4,
        "label": 0
    },
    {
        "mut_no": 1096,
        "test_method": "com.fasterxml.jackson.core.filter.JsonPointerParserFilteringTest.testSimplestNoPath",
        "source_method": "findSymbol(char[],int,int,int)",
        "src_lines": [
            "public String findSymbol(char[] buffer, int start, int len, int h)",
            "{",
            "if (len < 1) { // empty Strings are simplest to handle up front",
            "return \"\";",
            "}",
            "if (!_canonicalize) { // [JACKSON-259]",
            "return new String(buffer, start, len);",
            "}",
            "",
            "/* Related to problems with sub-standard hashing (somewhat",
            "* relevant for collision attacks too), let's try little",
            "* bit of shuffling to improve hash codes.",
            "* (note, however, that this can't help with full collisions)",
            "*/",
            "int index = _hashToIndex(h);",
            "String sym = _symbols[index];",
            "",
            "// Optimal case; checking existing primary symbol for hash index:",
            "if (sym != null) {",
            "// Let's inline primary String equality checking:",
            "if (sym.length() == len) {",
            "int i = 0;",
            "while (sym.charAt(i) == buffer[start+i]) {",
            "// Optimal case; primary match found",
            "if (++i == len) {",
            "return sym;",
            "}",
            "}",
            "}",
            "Bucket b = _buckets[index>>1];",
            "if (b != null) {",
            "sym = b.has(buffer, start, len);",
            "if (sym != null) {",
            "return sym;",
            "}",
            "sym = _findSymbol2(buffer, start, len, b.next);",
            "if (sym != null) {",
            "return sym;",
            "}",
            "}",
            "}",
            "return _addSymbol(buffer, start, len, h, index);",
            "}"
        ],
        "new_line": "if (len != 1) { // empty Strings are simplest to handle up front",
        "tst_lines": [
            "public void testSimplestNoPath() throws Exception",
            "{",
            "_assert(SIMPLEST_INPUT, \"/a\", false, \"1\");",
            "_assert(SIMPLEST_INPUT, \"/b\", false, \"2\");",
            "_assert(SIMPLEST_INPUT, \"/b/2\", false, \"\");",
            "_assert(SIMPLEST_INPUT, \"/c\", false, \"3\");",
            "_assert(SIMPLEST_INPUT, \"/d\", false, \"\");",
            "}"
        ],
        "before_pmt": "len, <, 1,",
        "after_pmt": "len, !=, 1,",
        "mutator": "ROR",
        "mut_src_line_no": 2,
        "label": 0
    },
    {
        "mut_no": 6207,
        "test_method": "com.fasterxml.jackson.core.main.TestParserFeatures.testTabsEnabled",
        "source_method": "_throwUnquotedSpace(int,java.lang.String)",
        "src_lines": [
            "protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {",
            "// JACKSON-208; possible to allow unquoted control chars:",
            "if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {",
            "char c = (char) i;",
            "String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;",
            "_reportError(msg);",
            "}",
            "}"
        ],
        "new_line": "if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i != INT_SPACE) {",
        "tst_lines": [
            "public void testTabsEnabled() throws Exception",
            "{",
            "_testTabsEnabled(false);",
            "_testTabsEnabled(true);",
            "}"
        ],
        "before_pmt": "i, >, INT_SPACE,",
        "after_pmt": "i, !=, INT_SPACE,",
        "mutator": "ROR",
        "mut_src_line_no": 2,
        "label": 1
    },
    {
        "mut_no": 20634,
        "test_method": "org.apache.commons.lang3.time.FastDateFormatTest.test_getInstance_String_Locale",
        "source_method": "init()",
        "src_lines": [
            "private void init() {",
            "final List<Rule> rulesList = parsePattern();",
            "mRules = rulesList.toArray(new Rule[rulesList.size()]);",
            "",
            "int len = 0;",
            "for (int i=mRules.length; --i >= 0; ) {",
            "len += mRules[i].estimateLength();",
            "}",
            "",
            "mMaxLengthEstimate = len;",
            "}"
        ],
        "new_line": "for (int i=mRules.length; --i >= -1; ) {",
        "tst_lines": [
            "public void test_getInstance_String_Locale() {",
            "final Locale realDefaultLocale = Locale.getDefault();",
            "try {",
            "Locale.setDefault(Locale.US);",
            "final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);",
            "final FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");",
            "final FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);",
            "",
            "assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);",
            "assertSame(format1, format3);",
            "assertEquals(Locale.GERMANY, format1.getLocale());",
            "",
            "} finally {",
            "Locale.setDefault(realDefaultLocale);",
            "}",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 5,
        "label": 1
    },
    {
        "mut_no": 2770,
        "test_method": "com.google.gson.functional.ParameterizedTypesTest.testParameterizedTypeWithReaderDeserialization",
        "source_method": "excludeField(java.lang.reflect.Field,boolean)",
        "src_lines": [
            "public boolean excludeField(Field field, boolean serialize) {",
            "if ((modifiers & field.getModifiers()) != 0) {",
            "return true;",
            "}",
            "",
            "if (version != Excluder.IGNORE_VERSIONS",
            "&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {",
            "return true;",
            "}",
            "",
            "if (field.isSynthetic()) {",
            "return true;",
            "}",
            "",
            "if (requireExpose) {",
            "Expose annotation = field.getAnnotation(Expose.class);",
            "if (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {",
            "return true;",
            "}",
            "}",
            "",
            "if (!serializeInnerClasses && isInnerClass(field.getType())) {",
            "return true;",
            "}",
            "",
            "if (isAnonymousOrLocal(field.getType())) {",
            "return true;",
            "}",
            "",
            "List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;",
            "if (!list.isEmpty()) {",
            "FieldAttributes fieldAttributes = new FieldAttributes(field);",
            "for (ExclusionStrategy exclusionStrategy : list) {",
            "if (exclusionStrategy.shouldSkipField(fieldAttributes)) {",
            "return true;",
            "}",
            "}",
            "}",
            "",
            "return false;",
            "}"
        ],
        "new_line": "if ((modifiers & field.getModifiers()) != -1) {",
        "tst_lines": [
            "public void testParameterizedTypeWithReaderDeserialization() throws Exception {",
            "BagOfPrimitives bag = new BagOfPrimitives();",
            "MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);",
            "Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();",
            "BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();",
            "Gson gson = new GsonBuilder().registerTypeAdapter(",
            "expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))",
            ".create();",
            "",
            "Reader json = new StringReader(expected.getExpectedJson());",
            "MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);",
            "assertEquals(expected, actual);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 21105,
        "test_method": "org.apache.commons.lang3.time.DateUtilsRoundingTest.testRoundDayOfMonth",
        "source_method": "appendTo(java.lang.StringBuffer,int)",
        "src_lines": [
            "public final void appendTo(final StringBuffer buffer, final int value) {",
            "buffer.append((char)(value / 10 + '0'));",
            "buffer.append((char)(value % 10 + '0'));",
            "}"
        ],
        "new_line": "buffer.append((char)(value % 0 + '0'));",
        "tst_lines": [
            "public void testRoundDayOfMonth() throws Exception {",
            "final int calendarField = Calendar.DAY_OF_MONTH;",
            "Date roundedUpDate, roundedDownDate, lastRoundedDownDate;",
            "Date minDate, maxDate;",
            "",
            "roundedUpDate = dateTimeParser.parse(\"June 2, 2008 0:00:00.000\");",
            "roundedDownDate = targetDayOfMonthDate;",
            "lastRoundedDownDate = dateTimeParser.parse(\"June 1, 2008 11:59:59.999\");",
            "baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);",
            "",
            "//round to January 1",
            "minDate = dateTimeParser.parse(\"December 31, 2007 12:00:00.000\");",
            "maxDate = dateTimeParser.parse(\"January 1, 2008 11:59:59.999\");",
            "roundToJanuaryFirst(minDate, maxDate, calendarField);",
            "}"
        ],
        "before_pmt": "10,",
        "after_pmt": "0,",
        "mutator": "LVR",
        "mut_src_line_no": 2,
        "label": 1
    },
    {
        "mut_no": 22334,
        "test_method": "com.fasterxml.jackson.core.read.JsonParserTest.testBytesAsSource",
        "source_method": "_skipWS()",
        "src_lines": [
            "private final int _skipWS() throws IOException",
            "{",
            "while (_inputPtr < _inputEnd) {",
            "int i = _inputBuffer[_inputPtr++] & 0xFF;",
            "if (i > INT_SPACE) {",
            "if (i == INT_SLASH || i == INT_HASH) {",
            "--_inputPtr;",
            "return _skipWS2();",
            "}",
            "return i;",
            "}",
            "if (i != INT_SPACE) {",
            "if (i == INT_LF) {",
            "++_currInputRow;",
            "_currInputRowStart = _inputPtr;",
            "} else if (i == INT_CR) {",
            "_skipCR();",
            "} else if (i != INT_TAB) {",
            "_throwInvalidSpace(i);",
            "}",
            "}",
            "}",
            "return _skipWS2();",
            "}"
        ],
        "new_line": "if (i >= INT_SPACE) {",
        "tst_lines": [
            "public void testBytesAsSource() throws Exception",
            "{",
            "String JSON = \"[ 1, 2, 3, 4 ]\";",
            "byte[] b = JSON.getBytes(\"UTF-8\");",
            "int offset = 50;",
            "int len = b.length;",
            "byte[] src = new byte[offset + len + offset];",
            "",
            "System.arraycopy(b, 0, src, offset, len);",
            "",
            "JsonParser p = JSON_FACTORY.createParser(src, offset, len);",
            "",
            "assertToken(JsonToken.START_ARRAY, p.nextToken());",
            "assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());",
            "assertEquals(1, p.getIntValue());",
            "assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());",
            "assertEquals(2, p.getIntValue());",
            "assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());",
            "assertEquals(3, p.getIntValue());",
            "assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());",
            "assertEquals(4, p.getIntValue());",
            "assertToken(JsonToken.END_ARRAY, p.nextToken());",
            "assertNull(p.nextToken());",
            "",
            "p.close();",
            "}"
        ],
        "before_pmt": "i, >, INT_SPACE,",
        "after_pmt": "i, >=, INT_SPACE,",
        "mutator": "ROR",
        "mut_src_line_no": 4,
        "label": 1
    },
    {
        "mut_no": 4148,
        "test_method": "com.google.gson.internal.bind.JsonTreeWriterTest.testLenientNansAndInfinities",
        "source_method": "value(double)",
        "src_lines": [
            "@Override public JsonWriter value(double value) throws IOException {",
            "if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {",
            "throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);",
            "}",
            "put(new JsonPrimitive(value));",
            "return this;",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testLenientNansAndInfinities() throws IOException {",
            "JsonTreeWriter writer = new JsonTreeWriter();",
            "writer.setLenient(true);",
            "writer.beginArray();",
            "writer.value(Double.NaN);",
            "writer.value(Double.NEGATIVE_INFINITY);",
            "writer.value(Double.POSITIVE_INFINITY);",
            "writer.endArray();",
            "assertEquals(\"[NaN,-Infinity,Infinity]\", writer.get().toString());",
            "}"
        ],
        "before_pmt": "!, isLenient, (, ), &&, (, Double, ., isNaN, (, value, ), ||, Double, ., isInfinite, (, value, ), ),",
        "after_pmt": "false,",
        "mutator": "COR",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 15,
        "test_method": "org.apache.commons.csv.CSVPrinterTest.testPrintRecordsWithObjectArray",
        "source_method": "isLineBreak(char)",
        "src_lines": [
            "private static boolean isLineBreak(final char c) {",
            "return c == LF || c == CR;",
            "}"
        ],
        "new_line": "return c <= LF || c == CR;",
        "tst_lines": [
            "public void testPrintRecordsWithObjectArray() throws IOException {",
            "final CharArrayWriter charArrayWriter = new CharArrayWriter(0);",
            "try (CSVPrinter csvPrinter = CSVFormat.INFORMIX_UNLOAD.print(charArrayWriter)) {",
            "final HashSet<BatchUpdateException> hashSet = new HashSet<>();",
            "final Object[] objectArray = new Object[6];",
            "objectArray[3] = hashSet;",
            "csvPrinter.printRecords(objectArray);",
            "}",
            "assertEquals(6, charArrayWriter.size());",
            "assertEquals(\"\\n\\n\\n\\n\\n\\n\", charArrayWriter.toString());",
            "}"
        ],
        "before_pmt": "c, ==, LF,",
        "after_pmt": "c, <=, LF,",
        "mutator": "ROR",
        "mut_src_line_no": 1,
        "label": 1
    },
    {
        "mut_no": 286,
        "test_method": "com.google.gson.functional.CustomDeserializerTest.testDefaultConstructorNotCalledOnField",
        "source_method": "beforeName()",
        "src_lines": [
            "private void beforeName() throws IOException {",
            "int context = peek();",
            "if (context == NONEMPTY_OBJECT) { // first in object",
            "out.write(',');",
            "} else if (context != EMPTY_OBJECT) { // not in an object!",
            "throw new IllegalStateException(\"Nesting problem.\");",
            "}",
            "newline();",
            "replaceTop(DANGLING_NAME);",
            "}"
        ],
        "new_line": "if (context <= NONEMPTY_OBJECT) { // first in object",
        "tst_lines": [
            "public void testDefaultConstructorNotCalledOnField() throws Exception {",
            "DataHolderWrapper dataWrapper = new DataHolderWrapper(new DataHolder(DEFAULT_VALUE));",
            "String json = gson.toJson(dataWrapper);",
            "",
            "DataHolderWrapper actual = gson.fromJson(json, DataHolderWrapper.class);",
            "assertEquals(DEFAULT_VALUE + SUFFIX, actual.getWrappedData().getData());",
            "}"
        ],
        "before_pmt": "context, ==, NONEMPTY_OBJECT,",
        "after_pmt": "context, <=, NONEMPTY_OBJECT,",
        "mutator": "ROR",
        "mut_src_line_no": 2,
        "label": 1
    },
    {
        "mut_no": 943,
        "test_method": "org.apache.commons.cli.HelpFormatterTest.testPrintUsage",
        "source_method": "printUsage(java.io.PrintWriter,int,java.lang.String,org.apache.commons.cli.Options)",
        "src_lines": [
            "public void printUsage(PrintWriter pw, int width, String app, Options options)",
            "{",
            "// initialise the string buffer",
            "StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");",
            "",
            "// create a list for processed option groups",
            "final Collection processedGroups = new ArrayList();",
            "",
            "// temp variable",
            "Option option;",
            "",
            "List optList = new ArrayList(options.getOptions());",
            "Collections.sort(optList, getOptionComparator());",
            "// iterate over the options",
            "for (Iterator i = optList.iterator(); i.hasNext();)",
            "{",
            "// get the next Option",
            "option = (Option) i.next();",
            "",
            "// check if the option is part of an OptionGroup",
            "OptionGroup group = options.getOptionGroup(option);",
            "",
            "// if the option is part of a group",
            "if (group != null)",
            "{",
            "// and if the group has not already been processed",
            "if (!processedGroups.contains(group))",
            "{",
            "// add the group to the processed list",
            "processedGroups.add(group);",
            "",
            "",
            "// add the usage clause",
            "appendOptionGroup(buff, group);",
            "}",
            "",
            "// otherwise the option was displayed in the group",
            "// previously so ignore it.",
            "}",
            "",
            "// if the Option is not part of an OptionGroup",
            "else",
            "{",
            "appendOption(buff, option, option.isRequired());",
            "}",
            "",
            "if (i.hasNext())",
            "{",
            "buff.append(\" \");",
            "}",
            "}",
            "",
            "",
            "// call printWrapped",
            "printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testPrintUsage()",
            "{",
            "Option optionA = new Option(\"a\", \"first\");",
            "Option optionB = new Option(\"b\", \"second\");",
            "Option optionC = new Option(\"c\", \"third\");",
            "Options opts = new Options();",
            "opts.addOption(optionA);",
            "opts.addOption(optionB);",
            "opts.addOption(optionC);",
            "HelpFormatter helpFormatter = new HelpFormatter();",
            "ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();",
            "PrintWriter printWriter = new PrintWriter(bytesOut);",
            "helpFormatter.printUsage(printWriter, 80, \"app\", opts);",
            "printWriter.close();",
            "assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, bytesOut.toString());",
            "}"
        ],
        "before_pmt": "printWrapped, (, pw, ,, width, ,, buff, ., toString, (, ), ., indexOf, (, ' ', ), +, 1, ,, buff, ., toString, (, ), ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 54,
        "label": 1
    },
    {
        "mut_no": 5621,
        "test_method": "com.fasterxml.jackson.core.json.TestDecorators.testInputDecoration",
        "source_method": "_parseIntValue()",
        "src_lines": [
            "protected int _parseIntValue() throws IOException",
            "{",
            "// Inlined variant of: _parseNumericValue(NR_INT)",
            "if (_currToken == JsonToken.VALUE_NUMBER_INT) {",
            "if (_intLength <= 9) {",
            "int i = _textBuffer.contentsAsInt(_numberNegative);",
            "_numberInt = i;",
            "_numTypesValid = NR_INT;",
            "return i;",
            "}",
            "}",
            "// if not optimizable, use more generic",
            "_parseNumericValue(NR_INT);",
            "if ((_numTypesValid & NR_INT) == 0) {",
            "convertNumberToInt();",
            "}",
            "return _numberInt;",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testInputDecoration() throws IOException",
            "{",
            "JsonFactory f = new JsonFactory();",
            "f.setInputDecorator(new SimpleInputDecorator());",
            "JsonParser jp;",
            "// first test with Reader",
            "jp = f.createParser(new StringReader(\"{ }\"));",
            "// should be overridden;",
            "assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());",
            "assertEquals(789, jp.getIntValue());",
            "jp.close();",
            "",
            "// similarly with InputStream",
            "jp = f.createParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\")));",
            "// should be overridden;",
            "assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());",
            "assertEquals(123, jp.getIntValue());",
            "jp.close();",
            "",
            "// and with raw bytes",
            "jp = f.createParser(\"[ ]\".getBytes(\"UTF-8\"));",
            "// should be overridden;",
            "assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());",
            "assertEquals(456, jp.getIntValue());",
            "jp.close();",
            "}"
        ],
        "before_pmt": "_currToken, ==, JsonToken, ., VALUE_NUMBER_INT,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 0
    },
    {
        "mut_no": 4042,
        "test_method": "com.fasterxml.jackson.core.util.TestDelegates.testNotDelegateCopyMethods",
        "source_method": "getTextBuffer()",
        "src_lines": [
            "public char[] getTextBuffer()",
            "{",
            "// Are we just using shared input buffer?",
            "if (_inputStart >= 0) return _inputBuffer;",
            "if (_resultArray != null)  return _resultArray;",
            "if (_resultString != null) {",
            "return (_resultArray = _resultString.toCharArray());",
            "}",
            "// Nope; but does it fit in just one segment?",
            "if (!_hasSegments) {",
            "return (_currentSegment == null) ? NO_CHARS : _currentSegment;",
            "}",
            "// Nope, need to have/create a non-segmented array and return it",
            "return contentsAsArray();",
            "}"
        ],
        "new_line": "if (_inputStart >= -1) return _inputBuffer;",
        "tst_lines": [
            "public void testNotDelegateCopyMethods() throws IOException",
            "{",
            "JsonParser jp = JSON_F.createParser(\"[{\\\"a\\\":[1,2,{\\\"b\\\":3}],\\\"c\\\":\\\"d\\\"},{\\\"e\\\":false},null]\");",
            "StringWriter sw = new StringWriter();",
            "JsonGenerator jg = new JsonGeneratorDelegate(JSON_F.createGenerator(sw), false) {",
            "@Override",
            "public void writeFieldName(String name) throws IOException {",
            "super.writeFieldName(name+\"-test\");",
            "super.writeBoolean(true);",
            "super.writeFieldName(name);",
            "}",
            "};",
            "jp.nextToken();",
            "jg.copyCurrentStructure(jp);",
            "jg.flush();",
            "assertEquals(\"[{\\\"a-test\\\":true,\\\"a\\\":[1,2,{\\\"b-test\\\":true,\\\"b\\\":3}],\\\"c-test\\\":true,\\\"c\\\":\\\"d\\\"},{\\\"e-test\\\":true,\\\"e\\\":false},null]\", sw.toString());",
            "jp.close();",
            "jg.close();",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 3,
        "label": 0
    },
    {
        "mut_no": 41955,
        "test_method": "org.jfree.chart.renderer.xy.junit.XYAreaRendererTests.testDrawWithNullInfo",
        "source_method": "getNextPaint()",
        "src_lines": [
            "public Paint getNextPaint() {",
            "Paint result",
            "= this.paintSequence[this.paintIndex % this.paintSequence.length];",
            "this.paintIndex++;",
            "return result;",
            "}"
        ],
        "new_line": "= this.paintSequence[this.paintIndex / this.paintSequence.length];",
        "tst_lines": [
            "public void testDrawWithNullInfo() {",
            "boolean success = false;",
            "try {",
            "DefaultTableXYDataset dataset = new DefaultTableXYDataset();",
            "",
            "XYSeries s1 = new XYSeries(\"Series 1\", true, false);",
            "s1.add(5.0, 5.0);",
            "s1.add(10.0, 15.5);",
            "s1.add(15.0, 9.5);",
            "s1.add(20.0, 7.5);",
            "dataset.addSeries(s1);",
            "",
            "XYSeries s2 = new XYSeries(\"Series 2\", true, false);",
            "s2.add(5.0, 5.0);",
            "s2.add(10.0, 15.5);",
            "s2.add(15.0, 9.5);",
            "s2.add(20.0, 3.5);",
            "dataset.addSeries(s2);",
            "XYPlot plot = new XYPlot(dataset,",
            "new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
            "new XYAreaRenderer());",
            "JFreeChart chart = new JFreeChart(plot);",
            "/* BufferedImage image = */ chart.createBufferedImage(300, 200,",
            "null);",
            "success = true;",
            "}",
            "catch (NullPointerException e) {",
            "e.printStackTrace();",
            "success = false;",
            "}",
            "assertTrue(success);",
            "}"
        ],
        "before_pmt": "this, ., paintIndex, %, this, ., paintSequence, ., length,",
        "after_pmt": "this, ., paintIndex, /, this, ., paintSequence, ., length,",
        "mutator": "AOR",
        "mut_src_line_no": 2,
        "label": 0
    },
    {
        "mut_no": 21484,
        "test_method": "org.apache.commons.lang3.time.FastDateParserTest.testShortDateStyleWithLocales",
        "source_method": "isNumber()",
        "src_lines": [
            "boolean isNumber() {",
            "char c= formatField.charAt(0);",
            "if(c=='\\'') {",
            "c= formatField.charAt(1);",
            "}",
            "return Character.isDigit(c);",
            "}"
        ],
        "new_line": "if(c<='\\'') {",
        "tst_lines": [
            "public void testShortDateStyleWithLocales() throws ParseException {",
            "DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);",
            "final Calendar cal = Calendar.getInstance();",
            "cal.clear();",
            "",
            "cal.set(2004, 1, 3);",
            "assertEquals(cal.getTime(), fdf.parse(\"2/3/04\"));",
            "",
            "fdf = getDateInstance(FastDateFormat.SHORT, SWEDEN);",
            "assertEquals(cal.getTime(), fdf.parse(\"2004-02-03\"));",
            "}"
        ],
        "before_pmt": "c, ==, '\\'',",
        "after_pmt": "c, <=, '\\'',",
        "mutator": "ROR",
        "mut_src_line_no": 2,
        "label": 0
    },
    {
        "mut_no": 4857,
        "test_method": "com.fasterxml.jackson.core.read.NextXxxAccessTest.testIsNextTokenName",
        "source_method": "asQuotedChars()",
        "src_lines": [
            "public final char[] asQuotedChars() {",
            "char[] result = _quotedChars;",
            "if (result == null) {",
            "result = BufferRecyclers.quoteAsJsonText(_value);",
            "_quotedChars = result;",
            "}",
            "return result;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testIsNextTokenName() throws Exception",
            "{",
            "_testIsNextTokenName1(MODE_INPUT_STREAM);",
            "_testIsNextTokenName1(MODE_INPUT_STREAM_THROTTLED);",
            "_testIsNextTokenName1(MODE_DATA_INPUT);",
            "_testIsNextTokenName1(MODE_READER);",
            "}"
        ],
        "before_pmt": "_quotedChars, =, result,",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 4,
        "label": 0
    },
    {
        "mut_no": 67242,
        "test_method": "org.jfree.data.xy.junit.VectorSeriesCollectionTests.testEquals",
        "source_method": "equals(java.lang.Object)",
        "src_lines": [
            "public boolean equals(Object obj) {",
            "if (obj == this) {",
            "return true;",
            "}",
            "if (!(obj instanceof ComparableObjectSeries)) {",
            "return false;",
            "}",
            "if (!super.equals(obj)) {",
            "return false;",
            "}",
            "ComparableObjectSeries that = (ComparableObjectSeries) obj;",
            "if (this.maximumItemCount != that.maximumItemCount) {",
            "return false;",
            "}",
            "if (this.autoSort != that.autoSort) {",
            "return false;",
            "}",
            "if (this.allowDuplicateXValues != that.allowDuplicateXValues) {",
            "return false;",
            "}",
            "if (!ObjectUtilities.equal(this.data, that.data)) {",
            "return false;",
            "}",
            "return true;",
            "}"
        ],
        "new_line": "if (that.autoSort) {",
        "tst_lines": [
            "public void testEquals() {",
            "VectorSeries s1 = new VectorSeries(\"Series\");",
            "s1.add(1.0, 1.1, 1.2, 1.3);",
            "VectorSeriesCollection c1 = new VectorSeriesCollection();",
            "c1.addSeries(s1);",
            "VectorSeries s2 = new VectorSeries(\"Series\");",
            "s2.add(1.0, 1.1, 1.2, 1.3);",
            "VectorSeriesCollection c2 = new VectorSeriesCollection();",
            "c2.addSeries(s2);",
            "assertTrue(c1.equals(c2));",
            "assertTrue(c2.equals(c1));",
            "",
            "c1.addSeries(new VectorSeries(\"Empty Series\"));",
            "assertFalse(c1.equals(c2));",
            "",
            "c2.addSeries(new VectorSeries(\"Empty Series\"));",
            "assertTrue(c1.equals(c2));",
            "}"
        ],
        "before_pmt": "this, ., autoSort, !=, that, ., autoSort,",
        "after_pmt": "that, ., autoSort,",
        "mutator": "ROR",
        "mut_src_line_no": 14,
        "label": 0
    },
    {
        "mut_no": 966,
        "test_method": "org.apache.commons.csv.CSVParserTest.testGetRecordPositionWithCRLF",
        "source_method": "readEndOfLine(int)",
        "src_lines": [
            "boolean readEndOfLine(int ch) throws IOException {",
            "// check if we have \\r\\n...",
            "if (ch == CR && reader.lookAhead() == LF) {",
            "// note: does not change ch outside of this method!",
            "ch = reader.read();",
            "// Save the EOL state",
            "if (firstEol == null) {",
            "this.firstEol = Constants.CRLF;",
            "}",
            "}",
            "// save EOL state here.",
            "if (firstEol == null) {",
            "if (ch == LF) {",
            "this.firstEol = LF_STRING;",
            "} else if (ch == CR) {",
            "this.firstEol = CR_STRING;",
            "}",
            "}",
            "",
            "return ch == LF || ch == CR;",
            "}"
        ],
        "new_line": "if (ch == CR == (reader.lookAhead() == LF)) {",
        "tst_lines": [
            "public void testGetRecordPositionWithCRLF() throws Exception {",
            "this.validateRecordPosition(CRLF);",
            "}"
        ],
        "before_pmt": "ch, ==, CR, &&, reader, ., lookAhead, (, ), ==, LF,",
        "after_pmt": "ch, ==, CR, ==, (, reader, ., lookAhead, (, ), ==, LF, ),",
        "mutator": "COR",
        "mut_src_line_no": 2,
        "label": 1
    },
    {
        "mut_no": 11164,
        "test_method": "com.fasterxml.jackson.core.read.JsonParserTest.testLongText",
        "source_method": "getText()",
        "src_lines": [
            "public final String getText() throws IOException",
            "{",
            "JsonToken t = _currToken;",
            "if (t == JsonToken.VALUE_STRING) {",
            "if (_tokenIncomplete) {",
            "_tokenIncomplete = false;",
            "_finishString(); // only strings can be incomplete",
            "}",
            "return _textBuffer.contentsAsString();",
            "}",
            "return _getText2(t);",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testLongText() throws Exception {",
            "// lengths chosen to tease out problems with buffer allocation...",
            "_testLongText(310);",
            "_testLongText(7700);",
            "_testLongText(49000);",
            "_testLongText(96000);",
            "}"
        ],
        "before_pmt": "t, ==, JsonToken, ., VALUE_STRING,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 0
    },
    {
        "mut_no": 246,
        "test_method": "com.google.gson.functional.ExposeFieldsTest.testExposedInterfaceFieldSerialization",
        "source_method": "string(java.lang.String)",
        "src_lines": [
            "private void string(String value) throws IOException {",
            "String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;",
            "out.write(\"\\\"\");",
            "int last = 0;",
            "int length = value.length();",
            "for (int i = 0; i < length; i++) {",
            "char c = value.charAt(i);",
            "String replacement;",
            "if (c < 128) {",
            "replacement = replacements[c];",
            "if (replacement == null) {",
            "continue;",
            "}",
            "} else if (c == '\\u2028') {",
            "replacement = \"\\\\u2028\";",
            "} else if (c == '\\u2029') {",
            "replacement = \"\\\\u2029\";",
            "} else {",
            "continue;",
            "}",
            "if (last < i) {",
            "out.write(value, last, i - last);",
            "}",
            "out.write(replacement);",
            "last = i + 1;",
            "}",
            "if (last < length) {",
            "out.write(value, last, length - last);",
            "}",
            "out.write(\"\\\"\");",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testExposedInterfaceFieldSerialization() throws Exception {",
            "String expected = \"{\\\"interfaceField\\\":{}}\";",
            "ClassWithInterfaceField target = new ClassWithInterfaceField(new SomeObject());",
            "String actual = gson.toJson(target);",
            "",
            "assertEquals(expected, actual);",
            "}"
        ],
        "before_pmt": "replacement, ==, null,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 10,
        "label": 1
    },
    {
        "mut_no": 72,
        "test_method": "com.google.gson.functional.CollectionTest.testSetSerialization",
        "source_method": "open(int,java.lang.String)",
        "src_lines": [
            "private JsonWriter open(int empty, String openBracket) throws IOException {",
            "beforeValue();",
            "push(empty);",
            "out.write(openBracket);",
            "return this;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testSetSerialization() {",
            "Set<Entry> set = new HashSet<Entry>();",
            "set.add(new Entry(1));",
            "set.add(new Entry(2));",
            "String json = gson.toJson(set);",
            "assertTrue(json.contains(\"1\"));",
            "assertTrue(json.contains(\"2\"));",
            "}"
        ],
        "before_pmt": "beforeValue, (, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 1,
        "label": 0
    },
    {
        "mut_no": 174,
        "test_method": "org.apache.commons.cli.OptionGroupTest.testTwoOptionsFromGroupWithProperties",
        "source_method": "clone()",
        "src_lines": [
            "public Object clone()",
            "{",
            "try",
            "{",
            "Option option = (Option) super.clone();",
            "option.values = new ArrayList(values);",
            "return option;",
            "}",
            "catch (CloneNotSupportedException cnse)",
            "{",
            "throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());",
            "}",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testTwoOptionsFromGroupWithProperties() throws Exception",
            "{",
            "String[] args = new String[] { \"-f\" };",
            "",
            "Properties properties = new Properties();",
            "properties.put(\"d\", \"true\");",
            "",
            "CommandLine cl = parser.parse( _options, args, properties);",
            "assertTrue(cl.hasOption(\"f\"));",
            "assertTrue(!cl.hasOption(\"d\"));",
            "}"
        ],
        "before_pmt": "option, ., values, =, new, ArrayList, (, values, ),",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 5,
        "label": 0
    },
    {
        "mut_no": 6184,
        "test_method": "org.apache.commons.lang3.ConversionTest.testByteArrayToInt",
        "source_method": "byteArrayToInt(byte[],int,int,int,int)",
        "src_lines": [
            "public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {",
            "if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {",
            "return dstInit;",
            "}",
            "if ((nBytes - 1) * 8 + dstPos >= 32) {",
            "throw new IllegalArgumentException(",
            "\"(nBytes-1)*8+dstPos is greather or equal to than 32\");",
            "}",
            "int out = dstInit;",
            "int shift = 0;",
            "for (int i = 0; i < nBytes; i++ ) {",
            "shift = i * 8 + dstPos;",
            "final int bits = (0xff & src[i + srcPos]) << shift;",
            "final int mask = 0xff << shift;",
            "out = (out & ~mask) | bits;",
            "}",
            "return out;",
            "}"
        ],
        "new_line": "if ((nBytes - 1) / 8 + dstPos >= 32) {",
        "tst_lines": [
            "public void testByteArrayToInt() {",
            "final byte[] src = new byte[]{",
            "(byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34,",
            "(byte)0x56, (byte)0x78};",
            "assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0));",
            "assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1));",
            "assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4));",
            "assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4));",
            "assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0));",
            "assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1));",
            "// assertEquals(0x56341278,Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4));",
            "}"
        ],
        "before_pmt": "(, nBytes, -, 1, ), *, 8,",
        "after_pmt": "(, nBytes, -, 1, ), /, 8,",
        "mutator": "AOR",
        "mut_src_line_no": 4,
        "label": 0
    },
    {
        "mut_no": 10752,
        "test_method": "org.apache.commons.lang3.RangeTest.testContains",
        "source_method": "<init>(T,T,java.util.Comparator<T>)",
        "src_lines": [
            "private Range(final T element1, final T element2, Comparator<T> comparator) {",
            "if (element1 == null || element2 == null) {",
            "throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" +",
            "element1 + \", element2=\" + element2);",
            "}",
            "if (comparator == null) {",
            "comparator = ComparableComparator.INSTANCE;",
            "}",
            "if (comparator.compare(element1, element2) < 1) {",
            "this.minimum = element1;",
            "this.maximum = element2;",
            "} else {",
            "this.minimum = element2;",
            "this.maximum = element1;",
            "}",
            "this.comparator = comparator;",
            "}"
        ],
        "new_line": "if (comparator.compare(element1, element2) != 1) {",
        "tst_lines": [
            "public void testContains() {",
            "assertFalse(intRange.contains(null));",
            "",
            "assertFalse(intRange.contains(5));",
            "assertTrue(intRange.contains(10));",
            "assertTrue(intRange.contains(15));",
            "assertTrue(intRange.contains(20));",
            "assertFalse(intRange.contains(25));",
            "}"
        ],
        "before_pmt": "comparator, ., compare, (, element1, ,, element2, ), <, 1,",
        "after_pmt": "comparator, ., compare, (, element1, ,, element2, ), !=, 1,",
        "mutator": "ROR",
        "mut_src_line_no": 8,
        "label": 0
    },
    {
        "mut_no": 15977,
        "test_method": "org.apache.commons.lang3.builder.ReflectionToStringBuilderExcludeTest.test_toStringExclude",
        "source_method": "accept(java.lang.reflect.Field)",
        "src_lines": [
            "protected boolean accept(final Field field) {",
            "if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {",
            "// Reject field from inner class.",
            "return false;",
            "}",
            "if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {",
            "// Reject transient fields.",
            "return false;",
            "}",
            "if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {",
            "// Reject static fields.",
            "return false;",
            "}",
            "if (this.excludeFieldNames != null",
            "&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {",
            "// Reject fields from the getExcludeFieldNames list.",
            "return false;",
            "}",
            "return true;",
            "}"
        ],
        "new_line": "&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 1) {",
        "tst_lines": [
            "public void test_toStringExclude() {",
            "final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD);",
            "this.validateSecretFieldAbsent(toString);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "1,",
        "mutator": "LVR",
        "mut_src_line_no": 14,
        "label": 1
    },
    {
        "mut_no": 75077,
        "test_method": "org.jfree.data.time.junit.HourTests.testNext",
        "source_method": "next()",
        "src_lines": [
            "public RegularTimePeriod next() {",
            "",
            "Hour result;",
            "if (this.hour != LAST_HOUR_IN_DAY) {",
            "result = new Hour(this.hour + 1, this.day);",
            "}",
            "else { // we are at the last hour in the day...",
            "Day nextDay = (Day) this.day.next();",
            "if (nextDay != null) {",
            "result = new Hour(FIRST_HOUR_IN_DAY, nextDay);",
            "}",
            "else {",
            "result = null;",
            "}",
            "}",
            "return result;",
            "",
            "}"
        ],
        "new_line": "if (this.hour > LAST_HOUR_IN_DAY) {",
        "tst_lines": [
            "public void testNext() {",
            "Hour h = new Hour(1, 12, 12, 2000);",
            "h = (Hour) h.next();",
            "assertEquals(2000, h.getYear());",
            "assertEquals(12, h.getMonth());",
            "assertEquals(12, h.getDayOfMonth());",
            "assertEquals(2, h.getHour());",
            "h = new Hour(23, 31, 12, 9999);",
            "assertNull(h.next());",
            "}"
        ],
        "before_pmt": "this, ., hour, !=, LAST_HOUR_IN_DAY,",
        "after_pmt": "this, ., hour, >, LAST_HOUR_IN_DAY,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 1
    },
    {
        "mut_no": 14979,
        "test_method": "org.apache.commons.lang3.builder.CompareToBuilderTest.testShortArrayHiddenByObject",
        "source_method": "append(short[],short[])",
        "src_lines": [
            "public CompareToBuilder append(final short[] lhs, final short[] rhs) {",
            "if (comparison != 0) {",
            "return this;",
            "}",
            "if (lhs == rhs) {",
            "return this;",
            "}",
            "if (lhs == null) {",
            "comparison = -1;",
            "return this;",
            "}",
            "if (rhs == null) {",
            "comparison = +1;",
            "return this;",
            "}",
            "if (lhs.length != rhs.length) {",
            "comparison = (lhs.length < rhs.length) ? -1 : +1;",
            "return this;",
            "}",
            "for (int i = 0; i < lhs.length && comparison == 0; i++) {",
            "append(lhs[i], rhs[i]);",
            "}",
            "return this;",
            "}"
        ],
        "new_line": "for (int i = 1; i < lhs.length && comparison == 0; i++) {",
        "tst_lines": [
            "public void testShortArrayHiddenByObject() {",
            "final short[] array1 = new short[2];",
            "array1[0] = 5;",
            "array1[1] = 6;",
            "final short[] array2 = new short[2];",
            "array2[0] = 5;",
            "array2[1] = 6;",
            "final short[] array3 = new short[3];",
            "array3[0] = 5;",
            "array3[1] = 6;",
            "array3[2] = 7;",
            "final Object obj1 = array1;",
            "final Object obj2 = array2;",
            "final Object obj3 = array3;",
            "assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);",
            "assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);",
            "assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);",
            "assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);",
            "",
            "array1[1] = 7;",
            "assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);",
            "assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "1,",
        "mutator": "LVR",
        "mut_src_line_no": 19,
        "label": 0
    },
    {
        "mut_no": 4136,
        "test_method": "org.jfree.chart.plot.junit.CombinedRangeCategoryPlotTests.testRemoveSubplot",
        "source_method": "getDataRange(org.jfree.chart.axis.ValueAxis)",
        "src_lines": [
            "public Range getDataRange(ValueAxis axis) {",
            "",
            "Range result = null;",
            "List mappedDatasets = new ArrayList();",
            "",
            "int rangeIndex = this.rangeAxes.indexOf(axis);",
            "if (rangeIndex >= 0) {",
            "mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));",
            "}",
            "else if (axis == getRangeAxis()) {",
            "mappedDatasets.addAll(datasetsMappedToRangeAxis(0));",
            "}",
            "",
            "// iterate through the datasets that map to the axis and get the union",
            "// of the ranges.",
            "Iterator iterator = mappedDatasets.iterator();",
            "while (iterator.hasNext()) {",
            "CategoryDataset d = (CategoryDataset) iterator.next();",
            "CategoryItemRenderer r = getRendererForDataset(d);",
            "if (r != null) {",
            "result = Range.combine(result, r.findRangeBounds(d));",
            "}",
            "}",
            "return result;",
            "",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testRemoveSubplot() {",
            "CombinedRangeCategoryPlot plot = new CombinedRangeCategoryPlot();",
            "CategoryPlot plot1 = new CategoryPlot();",
            "CategoryPlot plot2 = new CategoryPlot();",
            "CategoryPlot plot3 = new CategoryPlot();",
            "plot.add(plot1);",
            "plot.add(plot2);",
            "plot.add(plot3);",
            "plot.remove(plot2);",
            "List plots = plot.getSubplots();",
            "assertEquals(2, plots.size());",
            "}"
        ],
        "before_pmt": "r, !=, null,",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 19,
        "label": 1
    },
    {
        "mut_no": 26150,
        "test_method": "com.fasterxml.jackson.core.json.async.AsyncSimpleNestedTest.testStuffInObject",
        "source_method": "_skipWS(int)",
        "src_lines": [
            "private final int _skipWS(int ch) throws IOException",
            "{",
            "do {",
            "if (ch != INT_SPACE) {",
            "if (ch == INT_LF) {",
            "++_currInputRow;",
            "_currInputRowStart = _inputPtr;",
            "} else if (ch == INT_CR) {",
            "++_currInputRowAlt;",
            "_currInputRowStart = _inputPtr;",
            "} else if (ch != INT_TAB) {",
            "_throwInvalidSpace(ch);",
            "}",
            "}",
            "if (_inputPtr >= _inputEnd) {",
            "_currToken = JsonToken.NOT_AVAILABLE;",
            "return 0;",
            "}",
            "ch = _inputBuffer[_inputPtr++] & 0xFF;",
            "} while (ch <= 0x0020);",
            "return ch;",
            "}"
        ],
        "new_line": "",
        "tst_lines": [
            "public void testStuffInObject() throws Exception",
            "{",
            "byte[] data = _jsonDoc(aposToQuotes(",
            "\"{'foobar':[1,2,-999],'emptyObject':{},'emptyArray':[], 'other':{'':null} }\"));",
            "",
            "JsonFactory f = JSON_F;",
            "_testStuffInObject(f, data, 0, 100);",
            "_testStuffInObject(f, data, 0, 3);",
            "_testStuffInObject(f, data, 0, 1);",
            "",
            "_testStuffInObject(f, data, 1, 100);",
            "_testStuffInObject(f, data, 1, 3);",
            "_testStuffInObject(f, data, 1, 1);",
            "}"
        ],
        "before_pmt": "_currToken, =, JsonToken, ., NOT_AVAILABLE,",
        "after_pmt": "<noop>,",
        "mutator": "STD",
        "mut_src_line_no": 15,
        "label": 0
    },
    {
        "mut_no": 11028,
        "test_method": "com.fasterxml.jackson.core.base64.Base64BinaryParsingTest.testOkMissingPadding",
        "source_method": "ensureLoaded(int)",
        "src_lines": [
            "protected boolean ensureLoaded(int minimum) throws IOException {",
            "/* Let's assume here buffer has enough room -- this will always",
            "* be true for the limited used this method gets",
            "*/",
            "int gotten = (_inputEnd - _inputPtr);",
            "while (gotten < minimum) {",
            "int count;",
            "",
            "if (_in == null) { // block source",
            "count = -1;",
            "} else {",
            "count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);",
            "}",
            "if (count < 1) {",
            "return false;",
            "}",
            "_inputEnd += count;",
            "gotten += count;",
            "}",
            "return true;",
            "}"
        ],
        "new_line": "while (false) {",
        "tst_lines": [
            "public void testOkMissingPadding() throws IOException {",
            "final byte[] DOC1 = new byte[] { (byte) 0xAD };",
            "_testOkMissingPadding(DOC1, MODE_INPUT_STREAM);",
            "_testOkMissingPadding(DOC1, MODE_INPUT_STREAM_THROTTLED);",
            "_testOkMissingPadding(DOC1, MODE_READER);",
            "_testOkMissingPadding(DOC1, MODE_DATA_INPUT);",
            "",
            "final byte[] DOC2 = new byte[] { (byte) 0xAC, (byte) 0xDC };",
            "_testOkMissingPadding(DOC2, MODE_INPUT_STREAM);",
            "_testOkMissingPadding(DOC2, MODE_INPUT_STREAM_THROTTLED);",
            "_testOkMissingPadding(DOC2, MODE_READER);",
            "_testOkMissingPadding(DOC2, MODE_DATA_INPUT);",
            "}"
        ],
        "before_pmt": "gotten, <, minimum,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 5,
        "label": 1
    },
    {
        "mut_no": 16264,
        "test_method": "org.apache.commons.lang3.concurrent.TimedSemaphoreTest.testAcquireNoLimit",
        "source_method": "acquire()",
        "src_lines": [
            "public synchronized void acquire() throws InterruptedException {",
            "if (isShutdown()) {",
            "throw new IllegalStateException(\"TimedSemaphore is shut down!\");",
            "}",
            "",
            "if (task == null) {",
            "task = startTimer();",
            "}",
            "",
            "boolean canPass = false;",
            "do {",
            "canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit();",
            "if (!canPass) {",
            "wait();",
            "} else {",
            "acquireCount++;",
            "}",
            "} while (!canPass);",
            "}"
        ],
        "new_line": "canPass = getLimit() <= NO_LIMIT;",
        "tst_lines": [
            "public void testAcquireNoLimit() throws InterruptedException {",
            "final ScheduledExecutorService service = EasyMock",
            ".createMock(ScheduledExecutorService.class);",
            "final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);",
            "prepareStartTimer(service, future);",
            "EasyMock.replay(service, future);",
            "final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,",
            "PERIOD, UNIT, TimedSemaphore.NO_LIMIT);",
            "final int count = 1000;",
            "final CountDownLatch latch = new CountDownLatch(count);",
            "final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);",
            "t.start();",
            "latch.await();",
            "EasyMock.verify(service, future);",
            "}"
        ],
        "before_pmt": "getLimit, (, ), <=, NO_LIMIT, ||, acquireCount, <, getLimit, (, ),",
        "after_pmt": "getLimit, (, ), <=, NO_LIMIT,",
        "mutator": "COR",
        "mut_src_line_no": 11,
        "label": 0
    },
    {
        "mut_no": 8068,
        "test_method": "org.jfree.chart.junit.ChartPanelTests.test2502355_restoreAutoRangeBounds",
        "source_method": "get(int)",
        "src_lines": [
            "protected Object get(int index) {",
            "Object result = null;",
            "if (index >= 0 && index < this.size) {",
            "result = this.objects[index];",
            "}",
            "return result;",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void test2502355_restoreAutoRangeBounds() {",
            "DefaultXYDataset dataset = new DefaultXYDataset();",
            "JFreeChart chart = ChartFactory.createXYLineChart(\"TestChart\", \"X\",",
            "\"Y\", dataset, false);",
            "XYPlot plot = (XYPlot) chart.getPlot();",
            "plot.setRangeAxis(1, new NumberAxis(\"X2\"));",
            "ChartPanel panel = new ChartPanel(chart);",
            "chart.addChangeListener(this);",
            "this.chartChangeEvents.clear();",
            "panel.restoreAutoRangeBounds();",
            "assertEquals(1, this.chartChangeEvents.size());",
            "}"
        ],
        "before_pmt": "index, >=, 0, &&, index, <, this, ., size,",
        "after_pmt": "false,",
        "mutator": "COR",
        "mut_src_line_no": 2,
        "label": 0
    },
    {
        "mut_no": 80731,
        "test_method": "org.jfree.data.xy.junit.XYSeriesCollectionTests.testSerialization",
        "source_method": "<init>(org.jfree.data.xy.XYSeries)",
        "src_lines": [
            "public XYSeriesCollection(XYSeries series) {",
            "this.data = new java.util.ArrayList();",
            "this.intervalDelegate = new IntervalXYDelegate(this, false);",
            "addChangeListener(this.intervalDelegate);",
            "if (series != null) {",
            "this.data.add(series);",
            "series.addChangeListener(this);",
            "}",
            "setSelectionState(this);",
            "}"
        ],
        "new_line": "if (true) {",
        "tst_lines": [
            "public void testSerialization() {",
            "XYSeries s1 = new XYSeries(\"Series\");",
            "s1.add(1.0, 1.1);",
            "XYSeriesCollection c1 = new XYSeriesCollection();",
            "c1.addSeries(s1);",
            "XYSeriesCollection c2 = null;",
            "",
            "try {",
            "ByteArrayOutputStream buffer = new ByteArrayOutputStream();",
            "ObjectOutput out = new ObjectOutputStream(buffer);",
            "out.writeObject(c1);",
            "out.close();",
            "",
            "ObjectInput in = new ObjectInputStream(",
            "new ByteArrayInputStream(buffer.toByteArray()));",
            "c2 = (XYSeriesCollection) in.readObject();",
            "in.close();",
            "}",
            "catch (Exception e) {",
            "e.printStackTrace();",
            "}",
            "assertEquals(c1, c2);",
            "}"
        ],
        "before_pmt": "series, !=, null,",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 4,
        "label": 1
    },
    {
        "mut_no": 25,
        "test_method": "org.apache.commons.csv.issues.JiraCsv203Test.testQuoteModeAll",
        "source_method": "isLineBreak(java.lang.Character)",
        "src_lines": [
            "private static boolean isLineBreak(final Character c) {",
            "return c != null && isLineBreak(c.charValue());",
            "}"
        ],
        "new_line": "return true && isLineBreak(c.charValue());",
        "tst_lines": [
            "public void testQuoteModeAll() throws Exception {",
            "final CSVFormat format = CSVFormat.EXCEL",
            ".withNullString(\"N/A\")",
            ".withIgnoreSurroundingSpaces(true)",
            ".withQuoteMode(QuoteMode.ALL);",
            "",
            "final StringBuffer buffer = new StringBuffer();",
            "final CSVPrinter printer = new CSVPrinter(buffer, format);",
            "printer.printRecord(new Object[] { null, \"Hello\", null, \"World\" });",
            "",
            "Assert.assertEquals(\"\\\"N/A\\\",\\\"Hello\\\",\\\"N/A\\\",\\\"World\\\"\\r\\n\", buffer.toString());",
            "}"
        ],
        "before_pmt": "c, !=, null,",
        "after_pmt": "true,",
        "mutator": "ROR",
        "mut_src_line_no": 1,
        "label": 1
    },
    {
        "mut_no": 1471,
        "test_method": "com.google.gson.functional.DefaultTypeAdaptersTest.testBitSetDeserialization",
        "source_method": "fillBuffer(int)",
        "src_lines": [
            "private boolean fillBuffer(int minimum) throws IOException {",
            "char[] buffer = this.buffer;",
            "lineStart -= pos;",
            "if (limit != pos) {",
            "limit -= pos;",
            "System.arraycopy(buffer, pos, buffer, 0, limit);",
            "} else {",
            "limit = 0;",
            "}",
            "",
            "pos = 0;",
            "int total;",
            "while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {",
            "limit += total;",
            "",
            "// if this is the first read, consume an optional byte order mark (BOM) if it exists",
            "if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {",
            "pos++;",
            "lineStart++;",
            "minimum++;",
            "}",
            "",
            "if (limit >= minimum) {",
            "return true;",
            "}",
            "}",
            "return false;",
            "}"
        ],
        "new_line": "if (lineNumber == -1 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {",
        "tst_lines": [
            "public void testBitSetDeserialization() throws Exception {",
            "BitSet expected = new BitSet();",
            "expected.set(0);",
            "expected.set(2, 6);",
            "expected.set(8);",
            "",
            "Gson gson = new Gson();",
            "String json = gson.toJson(expected);",
            "assertEquals(expected, gson.fromJson(json, BitSet.class));",
            "",
            "json = \"[1,0,1,1,1,1,0,0,1,0,0,0]\";",
            "assertEquals(expected, gson.fromJson(json, BitSet.class));",
            "",
            "json = \"[\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"1\\\"]\";",
            "assertEquals(expected, gson.fromJson(json, BitSet.class));",
            "",
            "json = \"[true,false,true,true,true,true,false,false,true,false,false]\";",
            "assertEquals(expected, gson.fromJson(json, BitSet.class));",
            "}"
        ],
        "before_pmt": "0,",
        "after_pmt": "-, 1,",
        "mutator": "LVR",
        "mut_src_line_no": 16,
        "label": 1
    },
    {
        "mut_no": 65481,
        "test_method": "org.jfree.chart.renderer.xy.junit.HighLowRendererTests.testHashcode",
        "source_method": "equal(java.awt.Paint,java.awt.Paint)",
        "src_lines": [
            "public static boolean equal(Paint p1, Paint p2) {",
            "",
            "// handle cases where either or both arguments are null",
            "if (p1 == null) {",
            "return (p2 == null);",
            "}",
            "if (p2 == null) {",
            "return false;",
            "}",
            "",
            "boolean result = false;",
            "// handle GradientPaint as a special case...",
            "if (p1 instanceof GradientPaint && p2 instanceof GradientPaint) {",
            "GradientPaint gp1 = (GradientPaint) p1;",
            "GradientPaint gp2 = (GradientPaint) p2;",
            "result = gp1.getColor1().equals(gp2.getColor1())",
            "&& gp1.getColor2().equals(gp2.getColor2())",
            "&& gp1.getPoint1().equals(gp2.getPoint1())",
            "&& gp1.getPoint2().equals(gp2.getPoint2())",
            "&& gp1.isCyclic() == gp2.isCyclic()",
            "&& gp1.getTransparency() == gp1.getTransparency();",
            "}",
            "else {",
            "result = p1.equals(p2);",
            "}",
            "return result;",
            "",
            "}"
        ],
        "new_line": "if (false) {",
        "tst_lines": [
            "public void testHashcode() {",
            "HighLowRenderer r1 = new HighLowRenderer();",
            "HighLowRenderer r2 = new HighLowRenderer();",
            "assertTrue(r1.equals(r2));",
            "int h1 = r1.hashCode();",
            "int h2 = r2.hashCode();",
            "assertEquals(h1, h2);",
            "}"
        ],
        "before_pmt": "p1, ==, null,",
        "after_pmt": "false,",
        "mutator": "ROR",
        "mut_src_line_no": 3,
        "label": 1
    }
]